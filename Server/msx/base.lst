                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 3.6.0 #9615 (MINGW64)
                              4 ;--------------------------------------------------------
                              5 	.module base
                              6 	.optsdcc -mz80
                              7 	
                              8 ;--------------------------------------------------------
                              9 ; Public variables in this module
                             10 ;--------------------------------------------------------
                             11 	.globl _StartOpcServer
                             12 	.globl _GetByteFromConnection
                             13 	.globl _SendBytes
                             14 	.globl _DisconnectClient
                             15 	.globl _WaitForClientConnection
                             16 	.globl _ClientIsConnected
                             17 	.globl _DoTransportStuff
                             18 	.globl _ShutDownTransport
                             19 	.globl _InitializeTransport
                             20 	.globl _CanWriteAtAddress
                             21 	.globl _CanExecuteAtAddress
                             22 	.globl _MustTerminateServer
                             23 	.globl _DoEnvironmentStuff
                             24 	.globl _AsmCall
                             25 	.globl _strlen
                             26 	.globl _printf
                             27 	.globl _executeCommandPayloadLengths
                             28 	.globl _verbose
                             29 	.globl _clientIsConnected
                             30 	.globl _readPortBuffer
                             31 	.globl _getDataBuffer
                             32 	.globl _pendingCommand
                             33 	.globl _regs
                             34 	.globl _ProcessReceivedByte
                             35 	.globl _ProcessFirstCommandByte
                             36 	.globl _ProcessNextCommandByte
                             37 	.globl _ProcessNextByteToWrite
                             38 	.globl _RunCompletedCommand
                             39 	.globl _SendPortBytes
                             40 	.globl _SendMemoryBytes
                             41 	.globl _LoadRegistersBeforeExecutingCode
                             42 	.globl _SendResponseAfterExecutingCode
                             43 	.globl _SendErrorMessage
                             44 	.globl _SendByte
                             45 	.globl _HandleConnectionLifetime
                             46 	.globl _ReadFromPort
                             47 	.globl _WriteToPort
                             48 ;--------------------------------------------------------
                             49 ; special function registers
                             50 ;--------------------------------------------------------
                             51 ;--------------------------------------------------------
                             52 ; ram data
                             53 ;--------------------------------------------------------
                             54 	.area _DATA
   0000                      55 _regs::
   0000                      56 	.ds 12
   000C                      57 _pendingCommand::
   000C                      58 	.ds 35
   002F                      59 _getDataBuffer::
   002F                      60 	.ds 516
   0233                      61 _readPortBuffer::
   0233                      62 	.ds 512
                             63 ;--------------------------------------------------------
                             64 ; ram data
                             65 ;--------------------------------------------------------
                             66 	.area _INITIALIZED
   0000                      67 _clientIsConnected::
   0000                      68 	.ds 1
   0001                      69 _verbose::
   0001                      70 	.ds 1
   0002                      71 _executeCommandPayloadLengths::
   0002                      72 	.ds 4
                             73 ;--------------------------------------------------------
                             74 ; absolute external ram data
                             75 ;--------------------------------------------------------
                             76 	.area _DABS (ABS)
                             77 ;--------------------------------------------------------
                             78 ; global & static initialisations
                             79 ;--------------------------------------------------------
                             80 	.area _HOME
                             81 	.area _GSINIT
                             82 	.area _GSFINAL
                             83 	.area _GSINIT
                             84 ;--------------------------------------------------------
                             85 ; Home
                             86 ;--------------------------------------------------------
                             87 	.area _HOME
                             88 	.area _HOME
                             89 ;--------------------------------------------------------
                             90 ; code
                             91 ;--------------------------------------------------------
                             92 	.area _CODE
                             93 ;base.c:143: void StartOpcServer(void* transportInitData, bool _verbose)
                             94 ;	---------------------------------
                             95 ; Function StartOpcServer
                             96 ; ---------------------------------
   0000                      97 _StartOpcServer::
                             98 ;base.c:147: verbose = _verbose;
   0000 21 04 00      [10]   99 	ld	hl, #4+0
   0003 39            [11]  100 	add	hl, sp
   0004 7E            [ 7]  101 	ld	a, (hl)
   0005 32r01r00      [13]  102 	ld	(#_verbose + 0),a
                            103 ;base.c:148: if(!InitializeTransport(transportInitData))
   0008 C1            [10]  104 	pop	bc
   0009 E1            [10]  105 	pop	hl
   000A E5            [11]  106 	push	hl
   000B C5            [11]  107 	push	bc
   000C E5            [11]  108 	push	hl
   000D CDr00r00      [17]  109 	call	_InitializeTransport
   0010 F1            [10]  110 	pop	af
   0011 7D            [ 4]  111 	ld	a,l
   0012 B7            [ 4]  112 	or	a, a
                            113 ;base.c:149: return;
                            114 ;base.c:151: while(!MustTerminateServer())
   0013 C8            [11]  115 	ret	Z
   0014                     116 00105$:
   0014 CDr00r00      [17]  117 	call	_MustTerminateServer
   0017 7D            [ 4]  118 	ld	a,l
   0018 B7            [ 4]  119 	or	a, a
   0019 C2r00r00      [10]  120 	jp	NZ,_ShutDownTransport
                            121 ;base.c:153: DoEnvironmentStuff();
   001C CDr00r00      [17]  122 	call	_DoEnvironmentStuff
                            123 ;base.c:154: DoTransportStuff();
   001F CDr00r00      [17]  124 	call	_DoTransportStuff
                            125 ;base.c:155: HandleConnectionLifetime();
   0022 CDr02r0B      [17]  126 	call	_HandleConnectionLifetime
                            127 ;base.c:157: datum = GetByteFromConnection();
   0025 CDr00r00      [17]  128 	call	_GetByteFromConnection
   0028 45            [ 4]  129 	ld	b,l
                            130 ;base.c:158: if(datum != -1) {
   0029 78            [ 4]  131 	ld	a,b
   002A 3C            [ 4]  132 	inc	a
   002B 20 04         [12]  133 	jr	NZ,00126$
   002D 7C            [ 4]  134 	ld	a,h
   002E 3C            [ 4]  135 	inc	a
   002F 28 E3         [12]  136 	jr	Z,00105$
   0031                     137 00126$:
                            138 ;base.c:159: ProcessReceivedByte((byte)datum);
   0031 C5            [11]  139 	push	bc
   0032 33            [ 6]  140 	inc	sp
   0033 CDr3Cr00      [17]  141 	call	_ProcessReceivedByte
   0036 33            [ 6]  142 	inc	sp
   0037 18 DB         [12]  143 	jr	00105$
                            144 ;base.c:163: ShutDownTransport();
   0039 C3r00r00      [10]  145 	jp  _ShutDownTransport
                            146 ;base.c:171: void ProcessReceivedByte(byte datum)
                            147 ;	---------------------------------
                            148 ; Function ProcessReceivedByte
                            149 ; ---------------------------------
   003C                     150 _ProcessReceivedByte::
   003C DD E5         [15]  151 	push	ix
   003E DD 21 00 00   [14]  152 	ld	ix,#0
   0042 DD 39         [15]  153 	add	ix,sp
                            154 ;base.c:173: switch(pendingCommand.state)
   0044 01r0Cr00      [10]  155 	ld	bc,#_pendingCommand+0
   0047 0A            [ 7]  156 	ld	a,(bc)
   0048 5F            [ 4]  157 	ld	e,a
   0049 3E 02         [ 7]  158 	ld	a,#0x02
   004B 93            [ 4]  159 	sub	a, e
   004C 38 49         [12]  160 	jr	C,00106$
   004E 16 00         [ 7]  161 	ld	d,#0x00
   0050 21r56r00      [10]  162 	ld	hl,#00123$
   0053 19            [11]  163 	add	hl,de
   0054 19            [11]  164 	add	hl,de
                            165 ;base.c:175: case PCMD_NONE:
   0055 E9            [ 4]  166 	jp	(hl)
   0056                     167 00123$:
   0056 18 04         [12]  168 	jr	00101$
   0058 18 21         [12]  169 	jr	00104$
   005A 18 2E         [12]  170 	jr	00105$
   005C                     171 00101$:
                            172 ;base.c:176: pendingCommand.state = ProcessFirstCommandByte(datum);
   005C C5            [11]  173 	push	bc
   005D DD 7E 04      [19]  174 	ld	a,4 (ix)
   0060 F5            [11]  175 	push	af
   0061 33            [ 6]  176 	inc	sp
   0062 CDrA6r00      [17]  177 	call	_ProcessFirstCommandByte
   0065 33            [ 6]  178 	inc	sp
   0066 7D            [ 4]  179 	ld	a,l
   0067 C1            [10]  180 	pop	bc
   0068 02            [ 7]  181 	ld	(bc),a
                            182 ;base.c:177: if(pendingCommand.state == PCMD_PARTIAL) {
   0069 3D            [ 4]  183 	dec	a
   006A 20 2B         [12]  184 	jr	NZ,00106$
                            185 ;base.c:178: pendingCommand.buffer[0] = datum;
   006C 21r16r00      [10]  186 	ld	hl,#(_pendingCommand + 0x000a)
   006F DD 7E 04      [19]  187 	ld	a,4 (ix)
   0072 77            [ 7]  188 	ld	(hl),a
                            189 ;base.c:179: pendingCommand.bufferWritePointer = (byte*)&(pendingCommand.buffer[1]);
   0073 21r17r00      [10]  190 	ld	hl,#(_pendingCommand + 0x000b)
   0076 22r2Dr00      [16]  191 	ld	((_pendingCommand + 0x0021)), hl
                            192 ;base.c:181: break;
   0079 18 1C         [12]  193 	jr	00106$
                            194 ;base.c:182: case PCMD_PARTIAL:
   007B                     195 00104$:
                            196 ;base.c:183: pendingCommand.state = ProcessNextCommandByte(datum);
   007B C5            [11]  197 	push	bc
   007C DD 7E 04      [19]  198 	ld	a,4 (ix)
   007F F5            [11]  199 	push	af
   0080 33            [ 6]  200 	inc	sp
   0081 CDrCDr01      [17]  201 	call	_ProcessNextCommandByte
   0084 33            [ 6]  202 	inc	sp
   0085 7D            [ 4]  203 	ld	a,l
   0086 C1            [10]  204 	pop	bc
   0087 02            [ 7]  205 	ld	(bc),a
                            206 ;base.c:184: break;
   0088 18 0D         [12]  207 	jr	00106$
                            208 ;base.c:185: case PCMD_WRITING:
   008A                     209 00105$:
                            210 ;base.c:186: pendingCommand.state = ProcessNextByteToWrite(datum);
   008A C5            [11]  211 	push	bc
   008B DD 7E 04      [19]  212 	ld	a,4 (ix)
   008E F5            [11]  213 	push	af
   008F 33            [ 6]  214 	inc	sp
   0090 CDrAFr03      [17]  215 	call	_ProcessNextByteToWrite
   0093 33            [ 6]  216 	inc	sp
   0094 7D            [ 4]  217 	ld	a,l
   0095 C1            [10]  218 	pop	bc
   0096 02            [ 7]  219 	ld	(bc),a
                            220 ;base.c:187: };
   0097                     221 00106$:
                            222 ;base.c:189: if(pendingCommand.state == PCMD_FULL) {
   0097 0A            [ 7]  223 	ld	a,(bc)
   0098 D6 03         [ 7]  224 	sub	a, #0x03
   009A 20 07         [12]  225 	jr	NZ,00109$
                            226 ;base.c:190: RunCompletedCommand();
   009C C5            [11]  227 	push	bc
   009D CDr70r04      [17]  228 	call	_RunCompletedCommand
   00A0 C1            [10]  229 	pop	bc
                            230 ;base.c:191: pendingCommand.state = PCMD_NONE;
   00A1 AF            [ 4]  231 	xor	a, a
   00A2 02            [ 7]  232 	ld	(bc),a
   00A3                     233 00109$:
   00A3 DD E1         [14]  234 	pop	ix
   00A5 C9            [10]  235 	ret
                            236 ;base.c:195: byte ProcessFirstCommandByte(byte datum)
                            237 ;	---------------------------------
                            238 ; Function ProcessFirstCommandByte
                            239 ; ---------------------------------
   00A6                     240 _ProcessFirstCommandByte::
   00A6 DD E5         [15]  241 	push	ix
   00A8 DD 21 00 00   [14]  242 	ld	ix,#0
   00AC DD 39         [15]  243 	add	ix,sp
   00AE 3B            [ 6]  244 	dec	sp
                            245 ;base.c:197: byte commandCode = datum & 0xF0;
   00AF DD 7E 04      [19]  246 	ld	a,4 (ix)
   00B2 E6 F0         [ 7]  247 	and	a, #0xf0
                            248 ;base.c:199: if(commandCode == OPC_PING) {
   00B4 4F            [ 4]  249 	ld	c,a
   00B5 B7            [ 4]  250 	or	a, a
   00B6 20 27         [12]  251 	jr	NZ,00104$
                            252 ;base.c:201: if(verbose) print("- Received PING command\r\n");
   00B8 3Ar01r00      [13]  253 	ld	a,(#_verbose + 0)
   00BB B7            [ 4]  254 	or	a, a
   00BC 28 08         [12]  255 	jr	Z,00102$
   00BE 21r75r01      [10]  256 	ld	hl,#___str_0
   00C1 E5            [11]  257 	push	hl
   00C2 CDr00r00      [17]  258 	call	_printf
   00C5 F1            [10]  259 	pop	af
   00C6                     260 00102$:
                            261 ;base.c:202: SendByte(0, false);
   00C6 21 00 00      [10]  262 	ld	hl,#0x0000
   00C9 E5            [11]  263 	push	hl
   00CA CDrE9r0A      [17]  264 	call	_SendByte
                            265 ;base.c:203: SendByte(datum, true);
   00CD 26 01         [ 7]  266 	ld	h,#0x01
   00CF E3            [19]  267 	ex	(sp),hl
   00D0 33            [ 6]  268 	inc	sp
   00D1 DD 7E 04      [19]  269 	ld	a,4 (ix)
   00D4 F5            [11]  270 	push	af
   00D5 33            [ 6]  271 	inc	sp
   00D6 CDrE9r0A      [17]  272 	call	_SendByte
   00D9 F1            [10]  273 	pop	af
                            274 ;base.c:204: return PCMD_NONE;
   00DA 2E 00         [ 7]  275 	ld	l,#0x00
   00DC C3r71r01      [10]  276 	jp	00113$
   00DF                     277 00104$:
                            278 ;base.c:207: if(commandCode == OPC_EXECUTE) {
   00DF 79            [ 4]  279 	ld	a,c
   00E0 D6 10         [ 7]  280 	sub	a, #0x10
   00E2 20 31         [12]  281 	jr	NZ,00106$
                            282 ;base.c:208: pendingCommand.commandCode = commandCode;
   00E4 21r0Dr00      [10]  283 	ld	hl,#(_pendingCommand + 0x0001)
   00E7 71            [ 7]  284 	ld	(hl),c
                            285 ;base.c:209: pendingCommand.remainingBytes = (int)executeCommandPayloadLengths[datum & 3];
   00E8 11r02r00      [10]  286 	ld	de,#_executeCommandPayloadLengths+0
   00EB DD 7E 04      [19]  287 	ld	a,4 (ix)
   00EE E6 03         [ 7]  288 	and	a, #0x03
   00F0 6F            [ 4]  289 	ld	l, a
   00F1 26 00         [ 7]  290 	ld	h,#0x00
   00F3 19            [11]  291 	add	hl,de
   00F4 4E            [ 7]  292 	ld	c,(hl)
   00F5 06 00         [ 7]  293 	ld	b,#0x00
   00F7 ED 43r0Er00   [20]  294 	ld	((_pendingCommand + 0x0002)), bc
                            295 ;base.c:210: pendingCommand.stateData.registers.input = pendingCommand.remainingBytes;
   00FB 21r12r00      [10]  296 	ld	hl,#_pendingCommand + 6
   00FE 71            [ 7]  297 	ld	(hl),c
                            298 ;base.c:211: pendingCommand.stateData.registers.output = (byte)executeCommandPayloadLengths[(datum >> 2) & 3];
   00FF 01r13r00      [10]  299 	ld	bc,#_pendingCommand + 7
   0102 DD 7E 04      [19]  300 	ld	a,4 (ix)
   0105 0F            [ 4]  301 	rrca
   0106 0F            [ 4]  302 	rrca
   0107 E6 3F         [ 7]  303 	and	a,#0x3f
   0109 E6 03         [ 7]  304 	and	a, #0x03
   010B 6F            [ 4]  305 	ld	l,a
   010C 26 00         [ 7]  306 	ld	h,#0x00
   010E 19            [11]  307 	add	hl,de
   010F 7E            [ 7]  308 	ld	a,(hl)
   0110 02            [ 7]  309 	ld	(bc),a
                            310 ;base.c:214: return PCMD_PARTIAL;
   0111 2E 01         [ 7]  311 	ld	l,#0x01
   0113 18 5C         [12]  312 	jr	00113$
   0115                     313 00106$:
                            314 ;base.c:217: if(commandCode == OPC_READ_MEM || commandCode == OPC_WRITE_MEM) {
   0115 79            [ 4]  315 	ld	a,c
   0116 FE 20         [ 7]  316 	cp	a,#0x20
   0118 28 04         [12]  317 	jr	Z,00107$
   011A D6 30         [ 7]  318 	sub	a, #0x30
   011C 20 1B         [12]  319 	jr	NZ,00108$
   011E                     320 00107$:
                            321 ;base.c:218: pendingCommand.commandCode = commandCode;
   011E 21r0Dr00      [10]  322 	ld	hl,#(_pendingCommand + 0x0001)
   0121 71            [ 7]  323 	ld	(hl),c
                            324 ;base.c:219: pendingCommand.remainingBytes = ((datum & 0x0F) == 0 ? 4 : 2);
   0122 DD 7E 04      [19]  325 	ld	a,4 (ix)
   0125 E6 0F         [ 7]  326 	and	a, #0x0f
   0127 20 04         [12]  327 	jr	NZ,00115$
   0129 0E 04         [ 7]  328 	ld	c,#0x04
   012B 18 02         [12]  329 	jr	00116$
   012D                     330 00115$:
   012D 0E 02         [ 7]  331 	ld	c,#0x02
   012F                     332 00116$:
   012F 06 00         [ 7]  333 	ld	b,#0x00
   0131 ED 43r0Er00   [20]  334 	ld	((_pendingCommand + 0x0002)), bc
                            335 ;base.c:223: return PCMD_PARTIAL;
   0135 2E 01         [ 7]  336 	ld	l,#0x01
   0137 18 38         [12]  337 	jr	00113$
   0139                     338 00108$:
                            339 ;base.c:226: if(commandCode == OPC_READ_PORT || commandCode == OPC_WRITE_PORT) {
   0139 79            [ 4]  340 	ld	a,c
   013A FE 40         [ 7]  341 	cp	a,#0x40
   013C 28 04         [12]  342 	jr	Z,00110$
   013E D6 50         [ 7]  343 	sub	a, #0x50
   0140 20 1B         [12]  344 	jr	NZ,00111$
   0142                     345 00110$:
                            346 ;base.c:227: pendingCommand.commandCode = commandCode;
   0142 21r0Dr00      [10]  347 	ld	hl,#(_pendingCommand + 0x0001)
   0145 71            [ 7]  348 	ld	(hl),c
                            349 ;base.c:228: pendingCommand.remainingBytes = ((datum & 0x07) == 0 ? 3 : 1);
   0146 DD 7E 04      [19]  350 	ld	a,4 (ix)
   0149 E6 07         [ 7]  351 	and	a, #0x07
   014B 20 04         [12]  352 	jr	NZ,00117$
   014D 0E 03         [ 7]  353 	ld	c,#0x03
   014F 18 02         [12]  354 	jr	00118$
   0151                     355 00117$:
   0151 0E 01         [ 7]  356 	ld	c,#0x01
   0153                     357 00118$:
   0153 06 00         [ 7]  358 	ld	b,#0x00
   0155 ED 43r0Er00   [20]  359 	ld	((_pendingCommand + 0x0002)), bc
                            360 ;base.c:232: return PCMD_PARTIAL;
   0159 2E 01         [ 7]  361 	ld	l,#0x01
   015B 18 14         [12]  362 	jr	00113$
   015D                     363 00111$:
                            364 ;base.c:236: print("*** Unknown command received, disconnecting\r\n");
   015D 21r8Fr01      [10]  365 	ld	hl,#___str_1
   0160 E5            [11]  366 	push	hl
   0161 CDr00r00      [17]  367 	call	_printf
                            368 ;base.c:237: SendErrorMessage("Unknown command");
   0164 21rBDr01      [10]  369 	ld	hl, #___str_2
   0167 E3            [19]  370 	ex	(sp),hl
   0168 CDrBDr0A      [17]  371 	call	_SendErrorMessage
   016B F1            [10]  372 	pop	af
                            373 ;base.c:238: DisconnectClient();
   016C CDr00r00      [17]  374 	call	_DisconnectClient
                            375 ;base.c:239: return PCMD_NONE;
   016F 2E 00         [ 7]  376 	ld	l,#0x00
   0171                     377 00113$:
   0171 33            [ 6]  378 	inc	sp
   0172 DD E1         [14]  379 	pop	ix
   0174 C9            [10]  380 	ret
   0175                     381 ___str_0:
   0175 2D 20 52 65 63 65   382 	.ascii "- Received PING command"
        69 76 65 64 20 50
        49 4E 47 20 63 6F
        6D 6D 61 6E 64
   018C 0D                  383 	.db 0x0d
   018D 0A                  384 	.db 0x0a
   018E 00                  385 	.db 0x00
   018F                     386 ___str_1:
   018F 2A 2A 2A 20 55 6E   387 	.ascii "*** Unknown command received, disconnecting"
        6B 6E 6F 77 6E 20
        63 6F 6D 6D 61 6E
        64 20 72 65 63 65
        69 76 65 64 2C 20
        64 69 73 63 6F 6E
        6E 65 63 74 69 6E
        67
   01BA 0D                  388 	.db 0x0d
   01BB 0A                  389 	.db 0x0a
   01BC 00                  390 	.db 0x00
   01BD                     391 ___str_2:
   01BD 55 6E 6B 6E 6F 77   392 	.ascii "Unknown command"
        6E 20 63 6F 6D 6D
        61 6E 64
   01CC 00                  393 	.db 0x00
                            394 ;base.c:242: byte ProcessNextCommandByte(byte datum)
                            395 ;	---------------------------------
                            396 ; Function ProcessNextCommandByte
                            397 ; ---------------------------------
   01CD                     398 _ProcessNextCommandByte::
   01CD DD E5         [15]  399 	push	ix
   01CF DD 21 00 00   [14]  400 	ld	ix,#0
   01D3 DD 39         [15]  401 	add	ix,sp
   01D5 F5            [11]  402 	push	af
   01D6 3B            [ 6]  403 	dec	sp
                            404 ;base.c:247: *(pendingCommand.bufferWritePointer) = datum;
   01D7 01r0Cr00      [10]  405 	ld	bc,#_pendingCommand+0
   01DA 2Ar2Dr00      [16]  406 	ld	hl, (#(_pendingCommand + 0x0021) + 0)
   01DD DD 7E 04      [19]  407 	ld	a,4 (ix)
   01E0 77            [ 7]  408 	ld	(hl),a
                            409 ;base.c:248: pendingCommand.bufferWritePointer++;
   01E1 ED 5Br2Dr00   [20]  410 	ld	de, (#(_pendingCommand + 0x0021) + 0)
   01E5 13            [ 6]  411 	inc	de
   01E6 ED 53r2Dr00   [20]  412 	ld	((_pendingCommand + 0x0021)), de
                            413 ;base.c:249: pendingCommand.remainingBytes--;
   01EA 2Ar0Er00      [16]  414 	ld	hl, (#(_pendingCommand + 0x0002) + 0)
   01ED 7D            [ 4]  415 	ld	a,l
   01EE C6 FF         [ 7]  416 	add	a,#0xff
   01F0 57            [ 4]  417 	ld	d,a
   01F1 7C            [ 4]  418 	ld	a,h
   01F2 CE FF         [ 7]  419 	adc	a,#0xff
   01F4 5F            [ 4]  420 	ld	e,a
   01F5 21r0Er00      [10]  421 	ld	hl,#(_pendingCommand + 0x0002)
   01F8 72            [ 7]  422 	ld	(hl),d
   01F9 23            [ 6]  423 	inc	hl
   01FA 73            [ 7]  424 	ld	(hl),e
                            425 ;base.c:251: if(pendingCommand.remainingBytes != 0)
   01FB 7B            [ 4]  426 	ld	a,e
   01FC B2            [ 4]  427 	or	a,d
   01FD 28 05         [12]  428 	jr	Z,00102$
                            429 ;base.c:252: return PCMD_PARTIAL;
   01FF 2E 01         [ 7]  430 	ld	l,#0x01
   0201 C3r0Ar03      [10]  431 	jp	00117$
   0204                     432 00102$:
                            433 ;base.c:254: if(pendingCommand.commandCode != OPC_WRITE_MEM && pendingCommand.commandCode != OPC_WRITE_PORT)
   0204 21r0Dr00      [10]  434 	ld	hl, #(_pendingCommand + 0x0001) + 0
   0207 5E            [ 7]  435 	ld	e,(hl)
   0208 7B            [ 4]  436 	ld	a,e
   0209 D6 30         [ 7]  437 	sub	a, #0x30
   020B 20 04         [12]  438 	jr	NZ,00181$
   020D 3E 01         [ 7]  439 	ld	a,#0x01
   020F 18 01         [12]  440 	jr	00182$
   0211                     441 00181$:
   0211 AF            [ 4]  442 	xor	a,a
   0212                     443 00182$:
   0212 DD 77 FF      [19]  444 	ld	-1 (ix),a
   0215 DD CB FF 46   [20]  445 	bit	0,-1 (ix)
   0219 20 0A         [12]  446 	jr	NZ,00104$
   021B 7B            [ 4]  447 	ld	a,e
   021C D6 50         [ 7]  448 	sub	a, #0x50
   021E 28 05         [12]  449 	jr	Z,00104$
                            450 ;base.c:255: return PCMD_FULL;
   0220 2E 03         [ 7]  451 	ld	l,#0x03
   0222 C3r0Ar03      [10]  452 	jp	00117$
   0225                     453 00104$:
                            454 ;base.c:257: length = pendingCommand.buffer[0] & 0x07;
   0225 3Ar16r00      [13]  455 	ld	a, (#(_pendingCommand + 0x000a) + 0)
   0228 E6 07         [ 7]  456 	and	a, #0x07
   022A 5F            [ 4]  457 	ld	e,a
   022B 16 00         [ 7]  458 	ld	d,#0x00
                            459 ;base.c:258: if(length == 0) {
   022D 7A            [ 4]  460 	ld	a,d
   022E B3            [ 4]  461 	or	a,e
   022F 20 15         [12]  462 	jr	NZ,00107$
                            463 ;base.c:259: length = *((uint*)&(pendingCommand.buffer[pendingCommand.commandCode == OPC_WRITE_MEM ? 3 : 2]));
   0231 DD CB FF 46   [20]  464 	bit	0,-1 (ix)
   0235 28 04         [12]  465 	jr	Z,00119$
   0237 1E 03         [ 7]  466 	ld	e,#0x03
   0239 18 02         [12]  467 	jr	00120$
   023B                     468 00119$:
   023B 1E 02         [ 7]  469 	ld	e,#0x02
   023D                     470 00120$:
   023D 21r16r00      [10]  471 	ld	hl,#(_pendingCommand + 0x000a)
   0240 16 00         [ 7]  472 	ld	d,#0x00
   0242 19            [11]  473 	add	hl, de
   0243 5E            [ 7]  474 	ld	e,(hl)
   0244 23            [ 6]  475 	inc	hl
   0245 56            [ 7]  476 	ld	d,(hl)
   0246                     477 00107$:
                            478 ;base.c:261: if(length == 0) {
   0246 7A            [ 4]  479 	ld	a,d
                            480 ;base.c:262: return PCMD_NONE;
   0247 B3            [ 4]  481 	or	a,e
   0248 20 04         [12]  482 	jr	NZ,00109$
   024A 6F            [ 4]  483 	ld	l,a
   024B C3r0Ar03      [10]  484 	jp	00117$
   024E                     485 00109$:
                            486 ;base.c:265: pendingCommand.remainingBytes = length;
   024E ED 53r0Er00   [20]  487 	ld	((_pendingCommand + 0x0002)), de
                            488 ;base.c:266: if(pendingCommand.commandCode == OPC_WRITE_MEM) {
   0252 21r0Dr00      [10]  489 	ld	hl, #(_pendingCommand + 0x0001) + 0
   0255 5E            [ 7]  490 	ld	e,(hl)
                            491 ;base.c:267: address = *(byte**)&(pendingCommand.buffer[1]);
                            492 ;base.c:268: pendingCommand.stateData.memWrite.pointer = address;
                            493 ;base.c:266: if(pendingCommand.commandCode == OPC_WRITE_MEM) {
   0256 7B            [ 4]  494 	ld	a,e
   0257 D6 30         [ 7]  495 	sub	a, #0x30
   0259 20 5E         [12]  496 	jr	NZ,00115$
                            497 ;base.c:267: address = *(byte**)&(pendingCommand.buffer[1]);
   025B ED 5Br17r00   [20]  498 	ld	de, (#(_pendingCommand + 0x000b) + 0)
                            499 ;base.c:268: pendingCommand.stateData.memWrite.pointer = address;
   025F ED 53r12r00   [20]  500 	ld	((_pendingCommand + 0x0006)), de
                            501 ;base.c:269: pendingCommand.stateData.memWrite.isErrored = !CanWriteAtAddress(address);
   0263 C5            [11]  502 	push	bc
   0264 D5            [11]  503 	push	de
   0265 CDr00r00      [17]  504 	call	_CanWriteAtAddress
   0268 F1            [10]  505 	pop	af
   0269 5D            [ 4]  506 	ld	e,l
   026A C1            [10]  507 	pop	bc
   026B 7B            [ 4]  508 	ld	a,e
   026C D6 01         [ 7]  509 	sub	a,#0x01
   026E 3E 00         [ 7]  510 	ld	a,#0x00
   0270 17            [ 4]  511 	rla
   0271 5F            [ 4]  512 	ld	e,a
   0272 21r14r00      [10]  513 	ld	hl,#(_pendingCommand + 0x0008)
   0275 73            [ 7]  514 	ld	(hl),e
                            515 ;base.c:270: pendingCommand.stateData.memWrite.lockAddress = (bool)((pendingCommand.buffer[0] & (1<<3)) != 0);
   0276 3Ar16r00      [13]  516 	ld	a, (#(_pendingCommand + 0x000a) + 0)
   0279 CB 5F         [ 8]  517 	bit	3, a
   027B 28 04         [12]  518 	jr	Z,00121$
   027D 1E 01         [ 7]  519 	ld	e,#0x01
   027F 18 02         [12]  520 	jr	00122$
   0281                     521 00121$:
   0281 1E 00         [ 7]  522 	ld	e,#0x00
   0283                     523 00122$:
   0283 21r15r00      [10]  524 	ld	hl,#(_pendingCommand + 0x0009)
   0286 73            [ 7]  525 	ld	(hl),e
                            526 ;base.c:274: if(verbose) 
   0287 3Ar01r00      [13]  527 	ld	a,(#_verbose + 0)
   028A B7            [ 4]  528 	or	a, a
   028B 28 7B         [12]  529 	jr	Z,00116$
                            530 ;base.c:277: pendingCommand.stateData.memWrite.lockAddress ? ", lock address" : "");
   028D 3Ar15r00      [13]  531 	ld	a, (#(_pendingCommand + 0x0009) + 0)
   0290 B7            [ 4]  532 	or	a, a
   0291 28 05         [12]  533 	jr	Z,00123$
   0293 01r4Fr03      [10]  534 	ld	bc,#___str_4+0
   0296 18 03         [12]  535 	jr	00124$
   0298                     536 00123$:
   0298 01r5Er03      [10]  537 	ld	bc,#___str_5+0
   029B                     538 00124$:
   029B 33            [ 6]  539 	inc	sp
   029C 33            [ 6]  540 	inc	sp
   029D C5            [11]  541 	push	bc
                            542 ;base.c:276: pendingCommand.stateData.memWrite.pointer, pendingCommand.remainingBytes,
   029E ED 4Br0Er00   [20]  543 	ld	bc, (#(_pendingCommand + 0x0002) + 0)
   02A2 ED 5Br12r00   [20]  544 	ld	de, (#(_pendingCommand + 0x0006) + 0)
                            545 ;base.c:275: printf("- Received WRITE MEMORY command for address 0x%x, length=%u%s\r\n", 
   02A6 E1            [10]  546 	pop	hl
   02A7 E5            [11]  547 	push	hl
   02A8 E5            [11]  548 	push	hl
   02A9 C5            [11]  549 	push	bc
   02AA D5            [11]  550 	push	de
   02AB 21r0Fr03      [10]  551 	ld	hl,#___str_3
   02AE E5            [11]  552 	push	hl
   02AF CDr00r00      [17]  553 	call	_printf
   02B2 21 08 00      [10]  554 	ld	hl,#8
   02B5 39            [11]  555 	add	hl,sp
   02B6 F9            [ 6]  556 	ld	sp,hl
   02B7 18 4F         [12]  557 	jr	00116$
   02B9                     558 00115$:
                            559 ;base.c:280: pendingCommand.stateData.portWrite.port = *(byte*)&(pendingCommand.buffer[1]);
   02B9 3Ar17r00      [13]  560 	ld	a, (#(_pendingCommand + 0x000b) + 0)
   02BC 32r12r00      [13]  561 	ld	(#(_pendingCommand + 0x0006)),a
                            562 ;base.c:281: pendingCommand.stateData.portWrite.increment = (bool)((pendingCommand.buffer[0] & (1<<3)) != 0);
   02BF 21 07 00      [10]  563 	ld	hl,#0x0007
   02C2 09            [11]  564 	add	hl,bc
   02C3 4D            [ 4]  565 	ld	c,l
   02C4 44            [ 4]  566 	ld	b,h
   02C5 3Ar16r00      [13]  567 	ld	a, (#(_pendingCommand + 0x000a) + 0)
   02C8 CB 5F         [ 8]  568 	bit	3, a
   02CA 28 04         [12]  569 	jr	Z,00125$
   02CC 3E 01         [ 7]  570 	ld	a,#0x01
   02CE 18 02         [12]  571 	jr	00126$
   02D0                     572 00125$:
   02D0 3E 00         [ 7]  573 	ld	a,#0x00
   02D2                     574 00126$:
   02D2 02            [ 7]  575 	ld	(bc),a
                            576 ;base.c:285: if(verbose) 
   02D3 3Ar01r00      [13]  577 	ld	a,(#_verbose + 0)
   02D6 B7            [ 4]  578 	or	a, a
   02D7 28 2F         [12]  579 	jr	Z,00116$
                            580 ;base.c:288: pendingCommand.stateData.portWrite.increment ? "yes" : "no");
   02D9 0A            [ 7]  581 	ld	a,(bc)
   02DA B7            [ 4]  582 	or	a, a
   02DB 28 05         [12]  583 	jr	Z,00127$
   02DD 01rA8r03      [10]  584 	ld	bc,#___str_7+0
   02E0 18 03         [12]  585 	jr	00128$
   02E2                     586 00127$:
   02E2 01rACr03      [10]  587 	ld	bc,#___str_8+0
   02E5                     588 00128$:
                            589 ;base.c:287: pendingCommand.stateData.portWrite.port, pendingCommand.remainingBytes,
   02E5 ED 5Br0Er00   [20]  590 	ld	de, (#(_pendingCommand + 0x0002) + 0)
   02E9 3Ar12r00      [13]  591 	ld	a, (#(_pendingCommand + 0x0006) + 0)
   02EC DD 77 FD      [19]  592 	ld	-3 (ix),a
   02EF DD 36 FE 00   [19]  593 	ld	-2 (ix),#0x00
                            594 ;base.c:286: printf("- Received WRITE PORT command for port %u, length=%u, autoincrement=%s\r\n", 
   02F3 C5            [11]  595 	push	bc
   02F4 D5            [11]  596 	push	de
   02F5 DD 6E FD      [19]  597 	ld	l,-3 (ix)
   02F8 DD 66 FE      [19]  598 	ld	h,-2 (ix)
   02FB E5            [11]  599 	push	hl
   02FC 21r5Fr03      [10]  600 	ld	hl,#___str_6
   02FF E5            [11]  601 	push	hl
   0300 CDr00r00      [17]  602 	call	_printf
   0303 21 08 00      [10]  603 	ld	hl,#8
   0306 39            [11]  604 	add	hl,sp
   0307 F9            [ 6]  605 	ld	sp,hl
   0308                     606 00116$:
                            607 ;base.c:290: return PCMD_WRITING;
   0308 2E 02         [ 7]  608 	ld	l,#0x02
   030A                     609 00117$:
   030A DD F9         [10]  610 	ld	sp, ix
   030C DD E1         [14]  611 	pop	ix
   030E C9            [10]  612 	ret
   030F                     613 ___str_3:
   030F 2D 20 52 65 63 65   614 	.ascii "- Received WRITE MEMORY command for address 0x%x, length=%u%"
        69 76 65 64 20 57
        52 49 54 45 20 4D
        45 4D 4F 52 59 20
        63 6F 6D 6D 61 6E
        64 20 66 6F 72 20
        61 64 64 72 65 73
        73 20 30 78 25 78
        2C 20 6C 65 6E 67
        74 68 3D 25 75 25
   034B 73                  615 	.ascii "s"
   034C 0D                  616 	.db 0x0d
   034D 0A                  617 	.db 0x0a
   034E 00                  618 	.db 0x00
   034F                     619 ___str_4:
   034F 2C 20 6C 6F 63 6B   620 	.ascii ", lock address"
        20 61 64 64 72 65
        73 73
   035D 00                  621 	.db 0x00
   035E                     622 ___str_5:
   035E 00                  623 	.db 0x00
   035F                     624 ___str_6:
   035F 2D 20 52 65 63 65   625 	.ascii "- Received WRITE PORT command for port %u, length=%u, autoin"
        69 76 65 64 20 57
        52 49 54 45 20 50
        4F 52 54 20 63 6F
        6D 6D 61 6E 64 20
        66 6F 72 20 70 6F
        72 74 20 25 75 2C
        20 6C 65 6E 67 74
        68 3D 25 75 2C 20
        61 75 74 6F 69 6E
   039B 63 72 65 6D 65 6E   626 	.ascii "crement=%s"
        74 3D 25 73
   03A5 0D                  627 	.db 0x0d
   03A6 0A                  628 	.db 0x0a
   03A7 00                  629 	.db 0x00
   03A8                     630 ___str_7:
   03A8 79 65 73            631 	.ascii "yes"
   03AB 00                  632 	.db 0x00
   03AC                     633 ___str_8:
   03AC 6E 6F               634 	.ascii "no"
   03AE 00                  635 	.db 0x00
                            636 ;base.c:293: byte ProcessNextByteToWrite(byte datum)
                            637 ;	---------------------------------
                            638 ; Function ProcessNextByteToWrite
                            639 ; ---------------------------------
   03AF                     640 _ProcessNextByteToWrite::
   03AF DD E5         [15]  641 	push	ix
   03B1 DD 21 00 00   [14]  642 	ld	ix,#0
   03B5 DD 39         [15]  643 	add	ix,sp
                            644 ;base.c:295: if(pendingCommand.commandCode == OPC_WRITE_MEM) {
   03B7 21r0Dr00      [10]  645 	ld	hl, #(_pendingCommand + 0x0001) + 0
   03BA 5E            [ 7]  646 	ld	e,(hl)
                            647 ;base.c:296: if(!pendingCommand.stateData.memWrite.isErrored) {
   03BB 01r12r00      [10]  648 	ld	bc,#_pendingCommand + 6
                            649 ;base.c:295: if(pendingCommand.commandCode == OPC_WRITE_MEM) {
   03BE 7B            [ 4]  650 	ld	a,e
   03BF D6 30         [ 7]  651 	sub	a, #0x30
   03C1 20 22         [12]  652 	jr	NZ,00108$
                            653 ;base.c:296: if(!pendingCommand.stateData.memWrite.isErrored) {
   03C3 3Ar14r00      [13]  654 	ld	a, (#(_pendingCommand + 0x0008) + 0)
   03C6 B7            [ 4]  655 	or	a, a
   03C7 20 34         [12]  656 	jr	NZ,00109$
                            657 ;base.c:297: *(pendingCommand.stateData.memWrite.pointer) = datum;
   03C9 69            [ 4]  658 	ld	l, c
   03CA 60            [ 4]  659 	ld	h, b
   03CB 5E            [ 7]  660 	ld	e,(hl)
   03CC 23            [ 6]  661 	inc	hl
   03CD 56            [ 7]  662 	ld	d,(hl)
   03CE DD 7E 04      [19]  663 	ld	a,4 (ix)
   03D1 12            [ 7]  664 	ld	(de),a
                            665 ;base.c:298: if(!pendingCommand.stateData.memWrite.lockAddress) {
   03D2 3Ar15r00      [13]  666 	ld	a, (#_pendingCommand + 9)
   03D5 B7            [ 4]  667 	or	a, a
   03D6 20 25         [12]  668 	jr	NZ,00109$
                            669 ;base.c:299: pendingCommand.stateData.memWrite.pointer++;
   03D8 69            [ 4]  670 	ld	l, c
   03D9 60            [ 4]  671 	ld	h, b
   03DA 5E            [ 7]  672 	ld	e,(hl)
   03DB 23            [ 6]  673 	inc	hl
   03DC 56            [ 7]  674 	ld	d,(hl)
   03DD 13            [ 6]  675 	inc	de
   03DE 7B            [ 4]  676 	ld	a,e
   03DF 02            [ 7]  677 	ld	(bc),a
   03E0 03            [ 6]  678 	inc	bc
   03E1 7A            [ 4]  679 	ld	a,d
   03E2 02            [ 7]  680 	ld	(bc),a
   03E3 18 18         [12]  681 	jr	00109$
   03E5                     682 00108$:
                            683 ;base.c:304: WriteToPort(pendingCommand.stateData.portWrite.port, datum);
   03E5 0A            [ 7]  684 	ld	a,(bc)
   03E6 57            [ 4]  685 	ld	d,a
   03E7 C5            [11]  686 	push	bc
   03E8 DD 7E 04      [19]  687 	ld	a,4 (ix)
   03EB F5            [11]  688 	push	af
   03EC 33            [ 6]  689 	inc	sp
   03ED D5            [11]  690 	push	de
   03EE 33            [ 6]  691 	inc	sp
   03EF CDr9Ar0B      [17]  692 	call	_WriteToPort
   03F2 F1            [10]  693 	pop	af
   03F3 C1            [10]  694 	pop	bc
                            695 ;base.c:305: if(pendingCommand.stateData.portWrite.increment) {
   03F4 3Ar13r00      [13]  696 	ld	a, (#_pendingCommand + 7)
   03F7 B7            [ 4]  697 	or	a, a
   03F8 28 03         [12]  698 	jr	Z,00109$
                            699 ;base.c:306: pendingCommand.stateData.portWrite.port++;
   03FA 0A            [ 7]  700 	ld	a,(bc)
   03FB 3C            [ 4]  701 	inc	a
   03FC 02            [ 7]  702 	ld	(bc),a
   03FD                     703 00109$:
                            704 ;base.c:309: pendingCommand.remainingBytes--;
   03FD ED 4Br0Er00   [20]  705 	ld	bc, (#(_pendingCommand + 0x0002) + 0)
   0401 0B            [ 6]  706 	dec	bc
   0402 ED 43r0Er00   [20]  707 	ld	((_pendingCommand + 0x0002)), bc
                            708 ;base.c:311: if(pendingCommand.remainingBytes == 0) {
   0406 78            [ 4]  709 	ld	a,b
   0407 B1            [ 4]  710 	or	a,c
   0408 20 23         [12]  711 	jr	NZ,00115$
                            712 ;base.c:313: if(pendingCommand.commandCode == OPC_WRITE_MEM && pendingCommand.stateData.memWrite.isErrored) {
   040A 3Ar0Dr00      [13]  713 	ld	a, (#(_pendingCommand + 0x0001) + 0)
   040D D6 30         [ 7]  714 	sub	a, #0x30
   040F 20 10         [12]  715 	jr	NZ,00111$
   0411 3Ar14r00      [13]  716 	ld	a, (#(_pendingCommand + 0x0008) + 0)
   0414 B7            [ 4]  717 	or	a, a
   0415 28 0A         [12]  718 	jr	Z,00111$
                            719 ;base.c:314: SendErrorMessage("Can't write to this address, this space is used by the server");
   0417 21r32r04      [10]  720 	ld	hl,#___str_9
   041A E5            [11]  721 	push	hl
   041B CDrBDr0A      [17]  722 	call	_SendErrorMessage
   041E F1            [10]  723 	pop	af
   041F 18 08         [12]  724 	jr	00112$
   0421                     725 00111$:
                            726 ;base.c:317: SendByte(0, true);
   0421 21 00 01      [10]  727 	ld	hl,#0x0100
   0424 E5            [11]  728 	push	hl
   0425 CDrE9r0A      [17]  729 	call	_SendByte
   0428 F1            [10]  730 	pop	af
   0429                     731 00112$:
                            732 ;base.c:319: return PCMD_NONE;
   0429 2E 00         [ 7]  733 	ld	l,#0x00
   042B 18 02         [12]  734 	jr	00117$
   042D                     735 00115$:
                            736 ;base.c:322: return PCMD_WRITING;
   042D 2E 02         [ 7]  737 	ld	l,#0x02
   042F                     738 00117$:
   042F DD E1         [14]  739 	pop	ix
   0431 C9            [10]  740 	ret
   0432                     741 ___str_9:
   0432 43 61 6E 27 74 20   742 	.ascii "Can't write to this address, this space is used by the serve"
        77 72 69 74 65 20
        74 6F 20 74 68 69
        73 20 61 64 64 72
        65 73 73 2C 20 74
        68 69 73 20 73 70
        61 63 65 20 69 73
        20 75 73 65 64 20
        62 79 20 74 68 65
        20 73 65 72 76 65
   046E 72                  743 	.ascii "r"
   046F 00                  744 	.db 0x00
                            745 ;base.c:326: void RunCompletedCommand()
                            746 ;	---------------------------------
                            747 ; Function RunCompletedCommand
                            748 ; ---------------------------------
   0470                     749 _RunCompletedCommand::
   0470 DD E5         [15]  750 	push	ix
   0472 DD 21 00 00   [14]  751 	ld	ix,#0
   0476 DD 39         [15]  752 	add	ix,sp
   0478 21 F2 FF      [10]  753 	ld	hl,#-14
   047B 39            [11]  754 	add	hl,sp
   047C F9            [ 6]  755 	ld	sp,hl
                            756 ;base.c:336: if(pendingCommand.commandCode == OPC_EXECUTE) {
   047D 3Ar0Dr00      [13]  757 	ld	a,(#_pendingCommand + 1)
                            758 ;base.c:337: address = (byte*)*((int*)&(pendingCommand.buffer[1]));
                            759 ;base.c:336: if(pendingCommand.commandCode == OPC_EXECUTE) {
   0480 DD 77 FF      [19]  760 	ld	-1 (ix), a
   0483 D6 10         [ 7]  761 	sub	a, #0x10
   0485 C2r1Br05      [10]  762 	jp	NZ,00128$
                            763 ;base.c:337: address = (byte*)*((int*)&(pendingCommand.buffer[1]));
   0488 ED 4Br17r00   [20]  764 	ld	bc, (#(_pendingCommand + 0x000b) + 0)
                            765 ;base.c:339: if(!CanExecuteAtAddress(address)) {
   048C C5            [11]  766 	push	bc
   048D C5            [11]  767 	push	bc
   048E CDr00r00      [17]  768 	call	_CanExecuteAtAddress
   0491 F1            [10]  769 	pop	af
   0492 C1            [10]  770 	pop	bc
   0493 7D            [ 4]  771 	ld	a,l
   0494 B7            [ 4]  772 	or	a, a
   0495 20 1B         [12]  773 	jr	NZ,00112$
                            774 ;base.c:341: if(verbose) printf("- Received EXECUTE command for address 0x%x, error: bad address\r\n", address);
   0497 3Ar01r00      [13]  775 	ld	a,(#_verbose + 0)
   049A B7            [ 4]  776 	or	a, a
   049B 28 0A         [12]  777 	jr	Z,00102$
   049D C5            [11]  778 	push	bc
   049E 21rBCr06      [10]  779 	ld	hl,#___str_10
   04A1 E5            [11]  780 	push	hl
   04A2 CDr00r00      [17]  781 	call	_printf
   04A5 F1            [10]  782 	pop	af
   04A6 F1            [10]  783 	pop	af
   04A7                     784 00102$:
                            785 ;base.c:342: SendErrorMessage("Can't execute code at this address, this space is used by the server");            
   04A7 21rFEr06      [10]  786 	ld	hl,#___str_11
   04AA E5            [11]  787 	push	hl
   04AB CDrBDr0A      [17]  788 	call	_SendErrorMessage
   04AE F1            [10]  789 	pop	af
   04AF C3rB7r06      [10]  790 	jp	00130$
   04B2                     791 00112$:
                            792 ;base.c:344: else if(pendingCommand.stateData.registers.input == 22 || pendingCommand.stateData.registers.output == 22) {
   04B2 3Ar12r00      [13]  793 	ld	a, (#(_pendingCommand + 0x0006) + 0)
   04B5 D6 16         [ 7]  794 	sub	a, #0x16
   04B7 28 07         [12]  795 	jr	Z,00107$
   04B9 3Ar13r00      [13]  796 	ld	a, (#(_pendingCommand + 0x0007) + 0)
   04BC D6 16         [ 7]  797 	sub	a, #0x16
   04BE 20 1B         [12]  798 	jr	NZ,00108$
   04C0                     799 00107$:
                            800 ;base.c:346: if(verbose) printf("- Received EXECUTE command for address 0x%x, error: alt regs not supported\r\n", address);
   04C0 3Ar01r00      [13]  801 	ld	a,(#_verbose + 0)
   04C3 B7            [ 4]  802 	or	a, a
   04C4 28 0A         [12]  803 	jr	Z,00104$
   04C6 C5            [11]  804 	push	bc
   04C7 21r43r07      [10]  805 	ld	hl,#___str_12
   04CA E5            [11]  806 	push	hl
   04CB CDr00r00      [17]  807 	call	_printf
   04CE F1            [10]  808 	pop	af
   04CF F1            [10]  809 	pop	af
   04D0                     810 00104$:
                            811 ;base.c:347: SendErrorMessage("Setting alternate input/output registers is not supported by this server");
   04D0 21r90r07      [10]  812 	ld	hl,#___str_13
   04D3 E5            [11]  813 	push	hl
   04D4 CDrBDr0A      [17]  814 	call	_SendErrorMessage
   04D7 F1            [10]  815 	pop	af
   04D8 C3rB7r06      [10]  816 	jp	00130$
   04DB                     817 00108$:
                            818 ;base.c:351: if(verbose) printf("- Received EXECUTE command for address 0x%x\r\n", address);
   04DB 3Ar01r00      [13]  819 	ld	a,(#_verbose + 0)
   04DE B7            [ 4]  820 	or	a, a
   04DF 28 0C         [12]  821 	jr	Z,00106$
   04E1 C5            [11]  822 	push	bc
   04E2 C5            [11]  823 	push	bc
   04E3 21rD9r07      [10]  824 	ld	hl,#___str_14
   04E6 E5            [11]  825 	push	hl
   04E7 CDr00r00      [17]  826 	call	_printf
   04EA F1            [10]  827 	pop	af
   04EB F1            [10]  828 	pop	af
   04EC C1            [10]  829 	pop	bc
   04ED                     830 00106$:
                            831 ;base.c:352: LoadRegistersBeforeExecutingCode(pendingCommand.stateData.registers.input-2);
   04ED 3Ar12r00      [13]  832 	ld	a, (#(_pendingCommand + 0x0006) + 0)
   04F0 57            [ 4]  833 	ld	d,a
   04F1 15            [ 4]  834 	dec	d
   04F2 15            [ 4]  835 	dec	d
   04F3 C5            [11]  836 	push	bc
   04F4 D5            [11]  837 	push	de
   04F5 33            [ 6]  838 	inc	sp
   04F6 CDrBAr09      [17]  839 	call	_LoadRegistersBeforeExecutingCode
   04F9 33            [ 6]  840 	inc	sp
   04FA C1            [10]  841 	pop	bc
                            842 ;base.c:354: AsmCall((uint)address, &regs, REGS_ALL, REGS_ALL);
   04FB 21 03 03      [10]  843 	ld	hl,#0x0303
   04FE E5            [11]  844 	push	hl
   04FF 21r00r00      [10]  845 	ld	hl,#_regs
   0502 E5            [11]  846 	push	hl
   0503 C5            [11]  847 	push	bc
   0504 CDr00r00      [17]  848 	call	_AsmCall
   0507 21 06 00      [10]  849 	ld	hl,#6
   050A 39            [11]  850 	add	hl,sp
   050B F9            [ 6]  851 	ld	sp,hl
                            852 ;base.c:356: SendResponseAfterExecutingCode(pendingCommand.stateData.registers.output-2);
   050C 21r13r00      [10]  853 	ld	hl, #(_pendingCommand + 0x0007) + 0
   050F 46            [ 7]  854 	ld	b,(hl)
   0510 05            [ 4]  855 	dec	b
   0511 05            [ 4]  856 	dec	b
   0512 C5            [11]  857 	push	bc
   0513 33            [ 6]  858 	inc	sp
   0514 CDr32r0A      [17]  859 	call	_SendResponseAfterExecutingCode
   0517 33            [ 6]  860 	inc	sp
   0518 C3rB7r06      [10]  861 	jp	00130$
   051B                     862 00128$:
                            863 ;base.c:360: address = (byte*)*((int*)&(pendingCommand.buffer[1]));
                            864 ;base.c:359: else if(pendingCommand.commandCode == OPC_READ_MEM) {
   051B DD 7E FF      [19]  865 	ld	a,-1 (ix)
   051E D6 20         [ 7]  866 	sub	a, #0x20
   0520 C2rE5r05      [10]  867 	jp	NZ,00125$
                            868 ;base.c:360: address = (byte*)*((int*)&(pendingCommand.buffer[1]));
   0523 21r17r00      [10]  869 	ld	hl, #(_pendingCommand + 0x000b) + 0
   0526 7E            [ 7]  870 	ld	a,(hl)
   0527 DD 77 FD      [19]  871 	ld	-3 (ix),a
   052A 23            [ 6]  872 	inc	hl
   052B 7E            [ 7]  873 	ld	a,(hl)
   052C DD 77 FE      [19]  874 	ld	-2 (ix),a
   052F DD 7E FD      [19]  875 	ld	a,-3 (ix)
   0532 DD 77 F5      [19]  876 	ld	-11 (ix),a
   0535 DD 7E FE      [19]  877 	ld	a,-2 (ix)
   0538 DD 77 F6      [19]  878 	ld	-10 (ix),a
                            879 ;base.c:361: flags.lockAddress = (pendingCommand.buffer[0] & (1 << 3)) != 0;
   053B 21 00 00      [10]  880 	ld	hl,#0x0000
   053E 39            [11]  881 	add	hl,sp
   053F DD 75 FD      [19]  882 	ld	-3 (ix),l
   0542 DD 74 FE      [19]  883 	ld	-2 (ix),h
   0545 3Ar16r00      [13]  884 	ld	a, (#(_pendingCommand + 0x000a) + 0)
   0548 CB 5F         [ 8]  885 	bit	3, a
   054A 28 06         [12]  886 	jr	Z,00132$
   054C DD 36 FA 01   [19]  887 	ld	-6 (ix),#0x01
   0550 18 04         [12]  888 	jr	00133$
   0552                     889 00132$:
   0552 DD 36 FA 00   [19]  890 	ld	-6 (ix),#0x00
   0556                     891 00133$:
   0556 DD 6E FD      [19]  892 	ld	l,-3 (ix)
   0559 DD 66 FE      [19]  893 	ld	h,-2 (ix)
   055C DD 7E FA      [19]  894 	ld	a,-6 (ix)
   055F 77            [ 7]  895 	ld	(hl),a
                            896 ;base.c:362: length = pendingCommand.buffer[0] & 0x07;
   0560 3Ar16r00      [13]  897 	ld	a, (#(_pendingCommand + 0x000a) + 0)
   0563 E6 07         [ 7]  898 	and	a, #0x07
   0565 DD 77 FB      [19]  899 	ld	-5 (ix),a
                            900 ;base.c:363: if(length == 0) {
   0568 DD 36 FC 00   [19]  901 	ld	-4 (ix), #0x00
   056C 3E 00         [ 7]  902 	ld	a, #0x00
   056E DD B6 FB      [19]  903 	or	a,-5 (ix)
   0571 20 17         [12]  904 	jr	NZ,00115$
                            905 ;base.c:364: length = *((uint*)&(pendingCommand.buffer[3]));
   0573 DD 36 F8r19   [19]  906 	ld	-8 (ix),#<((_pendingCommand + 0x000d))
   0577 DD 36 F9s00   [19]  907 	ld	-7 (ix),#>((_pendingCommand + 0x000d))
   057B DD 6E F8      [19]  908 	ld	l,-8 (ix)
   057E DD 66 F9      [19]  909 	ld	h,-7 (ix)
   0581 7E            [ 7]  910 	ld	a,(hl)
   0582 DD 77 FB      [19]  911 	ld	-5 (ix),a
   0585 23            [ 6]  912 	inc	hl
   0586 7E            [ 7]  913 	ld	a,(hl)
   0587 DD 77 FC      [19]  914 	ld	-4 (ix),a
   058A                     915 00115$:
                            916 ;base.c:367: if(verbose) 
   058A 3Ar01r00      [13]  917 	ld	a,(#_verbose + 0)
   058D B7            [ 4]  918 	or	a, a
   058E 28 2D         [12]  919 	jr	Z,00117$
                            920 ;base.c:369: flags.lockAddress ? ", lock address" : "");
   0590 DD 6E FD      [19]  921 	ld	l,-3 (ix)
   0593 DD 66 FE      [19]  922 	ld	h,-2 (ix)
   0596 7E            [ 7]  923 	ld	a,(hl)
   0597 B7            [ 4]  924 	or	a, a
   0598 28 05         [12]  925 	jr	Z,00134$
   059A 01r46r08      [10]  926 	ld	bc,#___str_16+0
   059D 18 03         [12]  927 	jr	00135$
   059F                     928 00134$:
   059F 01r55r08      [10]  929 	ld	bc,#___str_17+0
   05A2                     930 00135$:
                            931 ;base.c:368: printf("- Received READ MEMORY command for address 0x%x, length=%u%s\r\n", address, length,
   05A2 C5            [11]  932 	push	bc
   05A3 DD 6E FB      [19]  933 	ld	l,-5 (ix)
   05A6 DD 66 FC      [19]  934 	ld	h,-4 (ix)
   05A9 E5            [11]  935 	push	hl
   05AA DD 6E F5      [19]  936 	ld	l,-11 (ix)
   05AD DD 66 F6      [19]  937 	ld	h,-10 (ix)
   05B0 E5            [11]  938 	push	hl
   05B1 21r07r08      [10]  939 	ld	hl,#___str_15
   05B4 E5            [11]  940 	push	hl
   05B5 CDr00r00      [17]  941 	call	_printf
   05B8 21 08 00      [10]  942 	ld	hl,#8
   05BB 39            [11]  943 	add	hl,sp
   05BC F9            [ 6]  944 	ld	sp,hl
   05BD                     945 00117$:
                            946 ;base.c:370: SendByte(0, false);
   05BD 21 00 00      [10]  947 	ld	hl,#0x0000
   05C0 E5            [11]  948 	push	hl
   05C1 CDrE9r0A      [17]  949 	call	_SendByte
   05C4 F1            [10]  950 	pop	af
                            951 ;base.c:371: SendMemoryBytes((byte*)address, length, flags.lockAddress);
   05C5 DD 6E FD      [19]  952 	ld	l,-3 (ix)
   05C8 DD 66 FE      [19]  953 	ld	h,-2 (ix)
   05CB 46            [ 7]  954 	ld	b,(hl)
   05CC C5            [11]  955 	push	bc
   05CD 33            [ 6]  956 	inc	sp
   05CE DD 6E FB      [19]  957 	ld	l,-5 (ix)
   05D1 DD 66 FC      [19]  958 	ld	h,-4 (ix)
   05D4 E5            [11]  959 	push	hl
   05D5 DD 6E F5      [19]  960 	ld	l,-11 (ix)
   05D8 DD 66 F6      [19]  961 	ld	h,-10 (ix)
   05DB E5            [11]  962 	push	hl
   05DC CDr00r09      [17]  963 	call	_SendMemoryBytes
   05DF F1            [10]  964 	pop	af
   05E0 F1            [10]  965 	pop	af
   05E1 33            [ 6]  966 	inc	sp
   05E2 C3rB7r06      [10]  967 	jp	00130$
   05E5                     968 00125$:
                            969 ;base.c:373: else if(pendingCommand.commandCode == OPC_READ_PORT) {
   05E5 DD 7E FF      [19]  970 	ld	a,-1 (ix)
   05E8 D6 40         [ 7]  971 	sub	a, #0x40
   05EA C2rB7r06      [10]  972 	jp	NZ,00130$
                            973 ;base.c:374: port = *((byte*)&(pendingCommand.buffer[1]));
   05ED 3Ar17r00      [13]  974 	ld	a,(#(_pendingCommand + 0x000b) + 0)
   05F0 DD 77 F7      [19]  975 	ld	-9 (ix),a
                            976 ;base.c:375: flags.incrementPort = (pendingCommand.buffer[0] & (1 << 3)) != 0;
   05F3 21 00 00      [10]  977 	ld	hl,#0x0000
   05F6 39            [11]  978 	add	hl,sp
   05F7 DD 75 F8      [19]  979 	ld	-8 (ix),l
   05FA DD 74 F9      [19]  980 	ld	-7 (ix),h
   05FD 3Ar16r00      [13]  981 	ld	a, (#(_pendingCommand + 0x000a) + 0)
   0600 CB 5F         [ 8]  982 	bit	3, a
   0602 28 06         [12]  983 	jr	Z,00136$
   0604 DD 36 FB 01   [19]  984 	ld	-5 (ix),#0x01
   0608 18 04         [12]  985 	jr	00137$
   060A                     986 00136$:
   060A DD 36 FB 00   [19]  987 	ld	-5 (ix),#0x00
   060E                     988 00137$:
   060E DD 6E F8      [19]  989 	ld	l,-8 (ix)
   0611 DD 66 F9      [19]  990 	ld	h,-7 (ix)
   0614 DD 7E FB      [19]  991 	ld	a,-5 (ix)
   0617 77            [ 7]  992 	ld	(hl),a
                            993 ;base.c:376: length = pendingCommand.buffer[0] & 0x07;
   0618 3Ar16r00      [13]  994 	ld	a,(#(_pendingCommand + 0x000a) + 0)
   061B DD 77 FB      [19]  995 	ld	-5 (ix), a
   061E E6 07         [ 7]  996 	and	a, #0x07
   0620 DD 77 FB      [19]  997 	ld	-5 (ix), a
   0623 DD 77 F3      [19]  998 	ld	-13 (ix),a
                            999 ;base.c:377: if(length == 0) {
   0626 DD 36 F4 00   [19] 1000 	ld	-12 (ix), #0x00
   062A 3E 00         [ 7] 1001 	ld	a, #0x00
   062C DD B6 F3      [19] 1002 	or	a,-13 (ix)
   062F 20 17         [12] 1003 	jr	NZ,00119$
                           1004 ;base.c:378: length = *((uint*)&(pendingCommand.buffer[2]));
   0631 DD 36 FBr18   [19] 1005 	ld	-5 (ix),#<((_pendingCommand + 0x000c))
   0635 DD 36 FCs00   [19] 1006 	ld	-4 (ix),#>((_pendingCommand + 0x000c))
   0639 DD 6E FB      [19] 1007 	ld	l,-5 (ix)
   063C DD 66 FC      [19] 1008 	ld	h,-4 (ix)
   063F 7E            [ 7] 1009 	ld	a,(hl)
   0640 DD 77 F3      [19] 1010 	ld	-13 (ix),a
   0643 23            [ 6] 1011 	inc	hl
   0644 7E            [ 7] 1012 	ld	a,(hl)
   0645 DD 77 F4      [19] 1013 	ld	-12 (ix),a
   0648                    1014 00119$:
                           1015 ;base.c:381: if(verbose) 
   0648 3Ar01r00      [13] 1016 	ld	a,(#_verbose + 0)
   064B B7            [ 4] 1017 	or	a, a
   064C 28 49         [12] 1018 	jr	Z,00121$
                           1019 ;base.c:383: port, length, flags.incrementPort ? "yes" : "no");
   064E DD 6E F8      [19] 1020 	ld	l,-8 (ix)
   0651 DD 66 F9      [19] 1021 	ld	h,-7 (ix)
   0654 7E            [ 7] 1022 	ld	a,(hl)
   0655 B7            [ 4] 1023 	or	a, a
   0656 28 0B         [12] 1024 	jr	Z,00138$
   0658 21r9Er08      [10] 1025 	ld	hl,#___str_19+0
   065B DD 75 FB      [19] 1026 	ld	-5 (ix),l
   065E DD 74 FC      [19] 1027 	ld	-4 (ix),h
   0661 18 09         [12] 1028 	jr	00139$
   0663                    1029 00138$:
   0663 21rA2r08      [10] 1030 	ld	hl,#___str_20+0
   0666 DD 75 FB      [19] 1031 	ld	-5 (ix),l
   0669 DD 74 FC      [19] 1032 	ld	-4 (ix),h
   066C                    1033 00139$:
   066C DD 7E F7      [19] 1034 	ld	a,-9 (ix)
   066F DD 77 FD      [19] 1035 	ld	-3 (ix),a
   0672 DD 36 FE 00   [19] 1036 	ld	-2 (ix),#0x00
                           1037 ;base.c:382: printf("- Received READ PORT command for port %u, length=%u, autoincrement=%s\r\n",
   0676 DD 6E FB      [19] 1038 	ld	l,-5 (ix)
   0679 DD 66 FC      [19] 1039 	ld	h,-4 (ix)
   067C E5            [11] 1040 	push	hl
   067D DD 6E F3      [19] 1041 	ld	l,-13 (ix)
   0680 DD 66 F4      [19] 1042 	ld	h,-12 (ix)
   0683 E5            [11] 1043 	push	hl
   0684 DD 6E FD      [19] 1044 	ld	l,-3 (ix)
   0687 DD 66 FE      [19] 1045 	ld	h,-2 (ix)
   068A E5            [11] 1046 	push	hl
   068B 21r56r08      [10] 1047 	ld	hl,#___str_18
   068E E5            [11] 1048 	push	hl
   068F CDr00r00      [17] 1049 	call	_printf
   0692 21 08 00      [10] 1050 	ld	hl,#8
   0695 39            [11] 1051 	add	hl,sp
   0696 F9            [ 6] 1052 	ld	sp,hl
   0697                    1053 00121$:
                           1054 ;base.c:384: SendByte(0, false);
   0697 21 00 00      [10] 1055 	ld	hl,#0x0000
   069A E5            [11] 1056 	push	hl
   069B CDrE9r0A      [17] 1057 	call	_SendByte
   069E F1            [10] 1058 	pop	af
                           1059 ;base.c:385: SendPortBytes(port, length, flags.incrementPort);
   069F DD 6E F8      [19] 1060 	ld	l,-8 (ix)
   06A2 DD 66 F9      [19] 1061 	ld	h,-7 (ix)
   06A5 46            [ 7] 1062 	ld	b,(hl)
   06A6 C5            [11] 1063 	push	bc
   06A7 33            [ 6] 1064 	inc	sp
   06A8 C1            [10] 1065 	pop	bc
   06A9 E1            [10] 1066 	pop	hl
   06AA E5            [11] 1067 	push	hl
   06AB C5            [11] 1068 	push	bc
   06AC E5            [11] 1069 	push	hl
   06AD DD 7E F7      [19] 1070 	ld	a,-9 (ix)
   06B0 F5            [11] 1071 	push	af
   06B1 33            [ 6] 1072 	inc	sp
   06B2 CDrA5r08      [17] 1073 	call	_SendPortBytes
   06B5 F1            [10] 1074 	pop	af
   06B6 F1            [10] 1075 	pop	af
   06B7                    1076 00130$:
   06B7 DD F9         [10] 1077 	ld	sp, ix
   06B9 DD E1         [14] 1078 	pop	ix
   06BB C9            [10] 1079 	ret
   06BC                    1080 ___str_10:
   06BC 2D 20 52 65 63 65  1081 	.ascii "- Received EXECUTE command for address 0x%x, error: bad addr"
        69 76 65 64 20 45
        58 45 43 55 54 45
        20 63 6F 6D 6D 61
        6E 64 20 66 6F 72
        20 61 64 64 72 65
        73 73 20 30 78 25
        78 2C 20 65 72 72
        6F 72 3A 20 62 61
        64 20 61 64 64 72
   06F8 65 73 73           1082 	.ascii "ess"
   06FB 0D                 1083 	.db 0x0d
   06FC 0A                 1084 	.db 0x0a
   06FD 00                 1085 	.db 0x00
   06FE                    1086 ___str_11:
   06FE 43 61 6E 27 74 20  1087 	.ascii "Can't execute code at this address, this space is used by th"
        65 78 65 63 75 74
        65 20 63 6F 64 65
        20 61 74 20 74 68
        69 73 20 61 64 64
        72 65 73 73 2C 20
        74 68 69 73 20 73
        70 61 63 65 20 69
        73 20 75 73 65 64
        20 62 79 20 74 68
   073A 65 20 73 65 72 76  1088 	.ascii "e server"
        65 72
   0742 00                 1089 	.db 0x00
   0743                    1090 ___str_12:
   0743 2D 20 52 65 63 65  1091 	.ascii "- Received EXECUTE command for address 0x%x, error: alt regs"
        69 76 65 64 20 45
        58 45 43 55 54 45
        20 63 6F 6D 6D 61
        6E 64 20 66 6F 72
        20 61 64 64 72 65
        73 73 20 30 78 25
        78 2C 20 65 72 72
        6F 72 3A 20 61 6C
        74 20 72 65 67 73
   077F 20 6E 6F 74 20 73  1092 	.ascii " not supported"
        75 70 70 6F 72 74
        65 64
   078D 0D                 1093 	.db 0x0d
   078E 0A                 1094 	.db 0x0a
   078F 00                 1095 	.db 0x00
   0790                    1096 ___str_13:
   0790 53 65 74 74 69 6E  1097 	.ascii "Setting alternate input/output registers is not supported by"
        67 20 61 6C 74 65
        72 6E 61 74 65 20
        69 6E 70 75 74 2F
        6F 75 74 70 75 74
        20 72 65 67 69 73
        74 65 72 73 20 69
        73 20 6E 6F 74 20
        73 75 70 70 6F 72
        74 65 64 20 62 79
   07CC 20 74 68 69 73 20  1098 	.ascii " this server"
        73 65 72 76 65 72
   07D8 00                 1099 	.db 0x00
   07D9                    1100 ___str_14:
   07D9 2D 20 52 65 63 65  1101 	.ascii "- Received EXECUTE command for address 0x%x"
        69 76 65 64 20 45
        58 45 43 55 54 45
        20 63 6F 6D 6D 61
        6E 64 20 66 6F 72
        20 61 64 64 72 65
        73 73 20 30 78 25
        78
   0804 0D                 1102 	.db 0x0d
   0805 0A                 1103 	.db 0x0a
   0806 00                 1104 	.db 0x00
   0807                    1105 ___str_15:
   0807 2D 20 52 65 63 65  1106 	.ascii "- Received READ MEMORY command for address 0x%x, length=%u%s"
        69 76 65 64 20 52
        45 41 44 20 4D 45
        4D 4F 52 59 20 63
        6F 6D 6D 61 6E 64
        20 66 6F 72 20 61
        64 64 72 65 73 73
        20 30 78 25 78 2C
        20 6C 65 6E 67 74
        68 3D 25 75 25 73
   0843 0D                 1107 	.db 0x0d
   0844 0A                 1108 	.db 0x0a
   0845 00                 1109 	.db 0x00
   0846                    1110 ___str_16:
   0846 2C 20 6C 6F 63 6B  1111 	.ascii ", lock address"
        20 61 64 64 72 65
        73 73
   0854 00                 1112 	.db 0x00
   0855                    1113 ___str_17:
   0855 00                 1114 	.db 0x00
   0856                    1115 ___str_18:
   0856 2D 20 52 65 63 65  1116 	.ascii "- Received READ PORT command for port %u, length=%u, autoinc"
        69 76 65 64 20 52
        45 41 44 20 50 4F
        52 54 20 63 6F 6D
        6D 61 6E 64 20 66
        6F 72 20 70 6F 72
        74 20 25 75 2C 20
        6C 65 6E 67 74 68
        3D 25 75 2C 20 61
        75 74 6F 69 6E 63
   0892 72 65 6D 65 6E 74  1117 	.ascii "rement=%s"
        3D 25 73
   089B 0D                 1118 	.db 0x0d
   089C 0A                 1119 	.db 0x0a
   089D 00                 1120 	.db 0x00
   089E                    1121 ___str_19:
   089E 79 65 73           1122 	.ascii "yes"
   08A1 00                 1123 	.db 0x00
   08A2                    1124 ___str_20:
   08A2 6E 6F              1125 	.ascii "no"
   08A4 00                 1126 	.db 0x00
                           1127 ;base.c:389: void SendPortBytes(byte port, uint length, bool increment)
                           1128 ;	---------------------------------
                           1129 ; Function SendPortBytes
                           1130 ; ---------------------------------
   08A5                    1131 _SendPortBytes::
   08A5 DD E5         [15] 1132 	push	ix
   08A7 DD 21 00 00   [14] 1133 	ld	ix,#0
   08AB DD 39         [15] 1134 	add	ix,sp
                           1135 ;base.c:391: uint remaining = length;
   08AD DD 4E 05      [19] 1136 	ld	c,5 (ix)
   08B0 DD 46 06      [19] 1137 	ld	b,6 (ix)
                           1138 ;base.c:394: if(length == 0) return;
   08B3 78            [ 4] 1139 	ld	a,b
   08B4 B1            [ 4] 1140 	or	a,c
                           1141 ;base.c:396: while(remaining > 0) {
   08B5 28 46         [12] 1142 	jr	Z,00106$
   08B7                    1143 00103$:
   08B7 78            [ 4] 1144 	ld	a,b
   08B8 B1            [ 4] 1145 	or	a,c
   08B9 28 42         [12] 1146 	jr	Z,00106$
                           1147 ;base.c:397: sendSize = remaining > SEND_CHUNK_SIZE ? SEND_CHUNK_SIZE : remaining;
   08BB AF            [ 4] 1148 	xor	a, a
   08BC B9            [ 4] 1149 	cp	a, c
   08BD 3E 02         [ 7] 1150 	ld	a,#0x02
   08BF 98            [ 4] 1151 	sbc	a, b
   08C0 30 05         [12] 1152 	jr	NC,00108$
   08C2 11 00 02      [10] 1153 	ld	de,#0x0200
   08C5 18 02         [12] 1154 	jr	00109$
   08C7                    1155 00108$:
   08C7 59            [ 4] 1156 	ld	e, c
   08C8 50            [ 4] 1157 	ld	d, b
   08C9                    1158 00109$:
                           1159 ;base.c:398: ReadFromPort(port, readPortBuffer, sendSize, increment);
   08C9 C5            [11] 1160 	push	bc
   08CA D5            [11] 1161 	push	de
   08CB DD 7E 07      [19] 1162 	ld	a,7 (ix)
   08CE F5            [11] 1163 	push	af
   08CF 33            [ 6] 1164 	inc	sp
   08D0 D5            [11] 1165 	push	de
   08D1 21r33r02      [10] 1166 	ld	hl,#_readPortBuffer
   08D4 E5            [11] 1167 	push	hl
   08D5 DD 7E 04      [19] 1168 	ld	a,4 (ix)
   08D8 F5            [11] 1169 	push	af
   08D9 33            [ 6] 1170 	inc	sp
   08DA CDr6Cr0B      [17] 1171 	call	_ReadFromPort
   08DD 21 06 00      [10] 1172 	ld	hl,#6
   08E0 39            [11] 1173 	add	hl,sp
   08E1 F9            [ 6] 1174 	ld	sp,hl
   08E2 D1            [10] 1175 	pop	de
   08E3 D5            [11] 1176 	push	de
   08E4 3E 01         [ 7] 1177 	ld	a,#0x01
   08E6 F5            [11] 1178 	push	af
   08E7 33            [ 6] 1179 	inc	sp
   08E8 D5            [11] 1180 	push	de
   08E9 21r33r02      [10] 1181 	ld	hl,#_readPortBuffer
   08EC E5            [11] 1182 	push	hl
   08ED CDr00r00      [17] 1183 	call	_SendBytes
   08F0 F1            [10] 1184 	pop	af
   08F1 F1            [10] 1185 	pop	af
   08F2 33            [ 6] 1186 	inc	sp
   08F3 D1            [10] 1187 	pop	de
   08F4 C1            [10] 1188 	pop	bc
                           1189 ;base.c:400: remaining -= sendSize;
   08F5 79            [ 4] 1190 	ld	a,c
   08F6 93            [ 4] 1191 	sub	a, e
   08F7 4F            [ 4] 1192 	ld	c,a
   08F8 78            [ 4] 1193 	ld	a,b
   08F9 9A            [ 4] 1194 	sbc	a, d
   08FA 47            [ 4] 1195 	ld	b,a
   08FB 18 BA         [12] 1196 	jr	00103$
   08FD                    1197 00106$:
   08FD DD E1         [14] 1198 	pop	ix
   08FF C9            [10] 1199 	ret
                           1200 ;base.c:404: void SendMemoryBytes(byte* address, uint length, bool lockAddress)
                           1201 ;	---------------------------------
                           1202 ; Function SendMemoryBytes
                           1203 ; ---------------------------------
   0900                    1204 _SendMemoryBytes::
   0900 DD E5         [15] 1205 	push	ix
   0902 DD 21 00 00   [14] 1206 	ld	ix,#0
   0906 DD 39         [15] 1207 	add	ix,sp
   0908 21 FA FF      [10] 1208 	ld	hl,#-6
   090B 39            [11] 1209 	add	hl,sp
   090C F9            [ 6] 1210 	ld	sp,hl
                           1211 ;base.c:410: if(length == 0) return;
   090D DD 7E 07      [19] 1212 	ld	a,7 (ix)
   0910 DD B6 06      [19] 1213 	or	a,6 (ix)
   0913 CArB5r09      [10] 1214 	jp	Z,00112$
                           1215 ;base.c:412: if(!lockAddress) {
   0916 DD 7E 08      [19] 1216 	ld	a,8 (ix)
   0919 B7            [ 4] 1217 	or	a, a
   091A 20 1B         [12] 1218 	jr	NZ,00104$
                           1219 ;base.c:413: SendBytes(address, length, true);
   091C 3E 01         [ 7] 1220 	ld	a,#0x01
   091E F5            [11] 1221 	push	af
   091F 33            [ 6] 1222 	inc	sp
   0920 DD 6E 06      [19] 1223 	ld	l,6 (ix)
   0923 DD 66 07      [19] 1224 	ld	h,7 (ix)
   0926 E5            [11] 1225 	push	hl
   0927 DD 6E 04      [19] 1226 	ld	l,4 (ix)
   092A DD 66 05      [19] 1227 	ld	h,5 (ix)
   092D E5            [11] 1228 	push	hl
   092E CDr00r00      [17] 1229 	call	_SendBytes
   0931 F1            [10] 1230 	pop	af
   0932 F1            [10] 1231 	pop	af
   0933 33            [ 6] 1232 	inc	sp
                           1233 ;base.c:414: return;
   0934 C3rB5r09      [10] 1234 	jp	00112$
   0937                    1235 00104$:
                           1236 ;base.c:417: remaining = length;
   0937 DD 4E 06      [19] 1237 	ld	c,6 (ix)
   093A DD 46 07      [19] 1238 	ld	b,7 (ix)
                           1239 ;base.c:418: while(remaining > 0) {
   093D 11r33r02      [10] 1240 	ld	de,#_readPortBuffer+0
   0940 DD 7E 04      [19] 1241 	ld	a,4 (ix)
   0943 DD 77 FE      [19] 1242 	ld	-2 (ix),a
   0946 DD 7E 05      [19] 1243 	ld	a,5 (ix)
   0949 DD 77 FF      [19] 1244 	ld	-1 (ix),a
   094C                    1245 00106$:
   094C 78            [ 4] 1246 	ld	a,b
   094D B1            [ 4] 1247 	or	a,c
   094E 28 65         [12] 1248 	jr	Z,00112$
                           1249 ;base.c:419: sendSize = remaining > SEND_CHUNK_SIZE ? SEND_CHUNK_SIZE : remaining;
   0950 AF            [ 4] 1250 	xor	a, a
   0951 B9            [ 4] 1251 	cp	a, c
   0952 3E 02         [ 7] 1252 	ld	a,#0x02
   0954 98            [ 4] 1253 	sbc	a, b
   0955 30 05         [12] 1254 	jr	NC,00114$
   0957 21 00 02      [10] 1255 	ld	hl,#0x0200
   095A 18 02         [12] 1256 	jr	00115$
   095C                    1257 00114$:
   095C 69            [ 4] 1258 	ld	l, c
   095D 60            [ 4] 1259 	ld	h, b
   095E                    1260 00115$:
   095E DD 75 FC      [19] 1261 	ld	-4 (ix),l
   0961 DD 74 FD      [19] 1262 	ld	-3 (ix),h
                           1263 ;base.c:420: for(i=0; i<sendSize; i++) {
   0964 21 00 00      [10] 1264 	ld	hl,#0x0000
   0967 E3            [19] 1265 	ex	(sp), hl
   0968                    1266 00110$:
   0968 DD 7E FA      [19] 1267 	ld	a,-6 (ix)
   096B DD 96 FC      [19] 1268 	sub	a, -4 (ix)
   096E DD 7E FB      [19] 1269 	ld	a,-5 (ix)
   0971 DD 9E FD      [19] 1270 	sbc	a, -3 (ix)
   0974 30 1A         [12] 1271 	jr	NC,00105$
                           1272 ;base.c:421: readPortBuffer[i] = *address;
   0976 FD E1         [14] 1273 	pop	iy
   0978 FD E5         [15] 1274 	push	iy
   097A FD 19         [15] 1275 	add	iy, de
   097C DD 6E FE      [19] 1276 	ld	l,-2 (ix)
   097F DD 66 FF      [19] 1277 	ld	h,-1 (ix)
   0982 6E            [ 7] 1278 	ld	l,(hl)
   0983 FD 75 00      [19] 1279 	ld	0 (iy), l
                           1280 ;base.c:420: for(i=0; i<sendSize; i++) {
   0986 DD 34 FA      [23] 1281 	inc	-6 (ix)
   0989 20 DD         [12] 1282 	jr	NZ,00110$
   098B DD 34 FB      [23] 1283 	inc	-5 (ix)
   098E 18 D8         [12] 1284 	jr	00110$
   0990                    1285 00105$:
                           1286 ;base.c:423: SendBytes(readPortBuffer, sendSize, true);
   0990 C5            [11] 1287 	push	bc
   0991 D5            [11] 1288 	push	de
   0992 3E 01         [ 7] 1289 	ld	a,#0x01
   0994 F5            [11] 1290 	push	af
   0995 33            [ 6] 1291 	inc	sp
   0996 DD 6E FC      [19] 1292 	ld	l,-4 (ix)
   0999 DD 66 FD      [19] 1293 	ld	h,-3 (ix)
   099C E5            [11] 1294 	push	hl
   099D 21r33r02      [10] 1295 	ld	hl,#_readPortBuffer
   09A0 E5            [11] 1296 	push	hl
   09A1 CDr00r00      [17] 1297 	call	_SendBytes
   09A4 F1            [10] 1298 	pop	af
   09A5 F1            [10] 1299 	pop	af
   09A6 33            [ 6] 1300 	inc	sp
   09A7 D1            [10] 1301 	pop	de
   09A8 C1            [10] 1302 	pop	bc
                           1303 ;base.c:424: remaining -= sendSize;
   09A9 79            [ 4] 1304 	ld	a,c
   09AA DD 96 FC      [19] 1305 	sub	a, -4 (ix)
   09AD 4F            [ 4] 1306 	ld	c,a
   09AE 78            [ 4] 1307 	ld	a,b
   09AF DD 9E FD      [19] 1308 	sbc	a, -3 (ix)
   09B2 47            [ 4] 1309 	ld	b,a
   09B3 18 97         [12] 1310 	jr	00106$
   09B5                    1311 00112$:
   09B5 DD F9         [10] 1312 	ld	sp, ix
   09B7 DD E1         [14] 1313 	pop	ix
   09B9 C9            [10] 1314 	ret
                           1315 ;base.c:428: void LoadRegistersBeforeExecutingCode(byte length)
                           1316 ;	---------------------------------
                           1317 ; Function LoadRegistersBeforeExecutingCode
                           1318 ; ---------------------------------
   09BA                    1319 _LoadRegistersBeforeExecutingCode::
   09BA DD E5         [15] 1320 	push	ix
   09BC DD 21 00 00   [14] 1321 	ld	ix,#0
   09C0 DD 39         [15] 1322 	add	ix,sp
                           1323 ;base.c:430: short* regsPointer = (short*)&(pendingCommand.buffer[3]);
   09C2 01r19r00      [10] 1324 	ld	bc,#_pendingCommand+13
                           1325 ;base.c:432: regs.Words.AF = regsPointer[0];
   09C5 69            [ 4] 1326 	ld	l, c
   09C6 60            [ 4] 1327 	ld	h, b
   09C7 5E            [ 7] 1328 	ld	e,(hl)
   09C8 23            [ 6] 1329 	inc	hl
   09C9 56            [ 7] 1330 	ld	d,(hl)
   09CA ED 53r00r00   [20] 1331 	ld	(_regs), de
                           1332 ;base.c:434: length -=2;
   09CE DD 35 04      [23] 1333 	dec	4 (ix)
   09D1 DD 35 04      [23] 1334 	dec	4 (ix)
                           1335 ;base.c:435: if(length == 0) return;
   09D4 DD 7E 04      [19] 1336 	ld	a,4 (ix)
   09D7 B7            [ 4] 1337 	or	a, a
   09D8 28 55         [12] 1338 	jr	Z,00107$
                           1339 ;base.c:437: regs.Words.BC = regsPointer[1];
   09DA 69            [ 4] 1340 	ld	l, c
   09DB 60            [ 4] 1341 	ld	h, b
   09DC 23            [ 6] 1342 	inc	hl
   09DD 23            [ 6] 1343 	inc	hl
   09DE 5E            [ 7] 1344 	ld	e,(hl)
   09DF 23            [ 6] 1345 	inc	hl
   09E0 56            [ 7] 1346 	ld	d,(hl)
   09E1 ED 53r02r00   [20] 1347 	ld	((_regs + 0x0002)), de
                           1348 ;base.c:438: regs.Words.DE = regsPointer[2];
   09E5 69            [ 4] 1349 	ld	l, c
   09E6 60            [ 4] 1350 	ld	h, b
   09E7 11 04 00      [10] 1351 	ld	de, #0x0004
   09EA 19            [11] 1352 	add	hl, de
   09EB 5E            [ 7] 1353 	ld	e,(hl)
   09EC 23            [ 6] 1354 	inc	hl
   09ED 56            [ 7] 1355 	ld	d,(hl)
   09EE ED 53r04r00   [20] 1356 	ld	((_regs + 0x0004)), de
                           1357 ;base.c:439: regs.Words.HL = regsPointer[3];
   09F2 69            [ 4] 1358 	ld	l, c
   09F3 60            [ 4] 1359 	ld	h, b
   09F4 11 06 00      [10] 1360 	ld	de, #0x0006
   09F7 19            [11] 1361 	add	hl, de
   09F8 5E            [ 7] 1362 	ld	e,(hl)
   09F9 23            [ 6] 1363 	inc	hl
   09FA 56            [ 7] 1364 	ld	d,(hl)
   09FB ED 53r06r00   [20] 1365 	ld	((_regs + 0x0006)), de
                           1366 ;base.c:443: length -=6;
   09FF DD 7E 04      [19] 1367 	ld	a,4 (ix)
   0A02 C6 FA         [ 7] 1368 	add	a,#0xfa
                           1369 ;base.c:444: if(length == 0) return;
   0A04 DD 77 04      [19] 1370 	ld	4 (ix), a
   0A07 B7            [ 4] 1371 	or	a, a
   0A08 28 25         [12] 1372 	jr	Z,00107$
                           1373 ;base.c:446: regs.Words.IX = regsPointer[4];
   0A0A 69            [ 4] 1374 	ld	l, c
   0A0B 60            [ 4] 1375 	ld	h, b
   0A0C 11 08 00      [10] 1376 	ld	de, #0x0008
   0A0F 19            [11] 1377 	add	hl, de
   0A10 5E            [ 7] 1378 	ld	e,(hl)
   0A11 23            [ 6] 1379 	inc	hl
   0A12 56            [ 7] 1380 	ld	d,(hl)
   0A13 ED 53r08r00   [20] 1381 	ld	((_regs + 0x0008)), de
                           1382 ;base.c:447: regs.Words.IY = regsPointer[5];
   0A17 69            [ 4] 1383 	ld	l, c
   0A18 60            [ 4] 1384 	ld	h, b
   0A19 11 0A 00      [10] 1385 	ld	de, #0x000a
   0A1C 19            [11] 1386 	add	hl, de
   0A1D 4E            [ 7] 1387 	ld	c,(hl)
   0A1E 23            [ 6] 1388 	inc	hl
   0A1F 46            [ 7] 1389 	ld	b,(hl)
   0A20 ED 43r0Ar00   [20] 1390 	ld	((_regs + 0x000a)), bc
                           1391 ;base.c:450: length -=4;
   0A24 DD 7E 04      [19] 1392 	ld	a,4 (ix)
   0A27 C6 FC         [ 7] 1393 	add	a,#0xfc
                           1394 ;base.c:451: if(length == 0) return;
   0A29 DD 77 04      [19] 1395 	ld	4 (ix), a
   0A2C B7            [ 4] 1396 	or	a, a
   0A2D 20 00         [12] 1397 	jr	NZ,00107$
   0A2F                    1398 00107$:
   0A2F DD E1         [14] 1399 	pop	ix
   0A31 C9            [10] 1400 	ret
                           1401 ;base.c:461: void SendResponseAfterExecutingCode(byte length)
                           1402 ;	---------------------------------
                           1403 ; Function SendResponseAfterExecutingCode
                           1404 ; ---------------------------------
   0A32                    1405 _SendResponseAfterExecutingCode::
   0A32 DD E5         [15] 1406 	push	ix
   0A34 DD 21 00 00   [14] 1407 	ld	ix,#0
   0A38 DD 39         [15] 1408 	add	ix,sp
                           1409 ;base.c:463: short* regsPointer = (short*)&(pendingCommand.buffer[3]);
   0A3A 01r19r00      [10] 1410 	ld	bc,#_pendingCommand + 13
                           1411 ;base.c:464: pendingCommand.buffer[2] = 0; //First byte of "ok" response
   0A3D 21r18r00      [10] 1412 	ld	hl,#(_pendingCommand + 0x000c)
   0A40 36 00         [10] 1413 	ld	(hl),#0x00
                           1414 ;base.c:466: regsPointer[0] = regs.Words.AF;
   0A42 ED 5Br00r00   [20] 1415 	ld	de, (#_regs + 0)
   0A46 69            [ 4] 1416 	ld	l, c
   0A47 60            [ 4] 1417 	ld	h, b
   0A48 73            [ 7] 1418 	ld	(hl),e
   0A49 23            [ 6] 1419 	inc	hl
   0A4A 72            [ 7] 1420 	ld	(hl),d
                           1421 ;base.c:468: if(length > 2) {
   0A4B 3E 02         [ 7] 1422 	ld	a,#0x02
   0A4D DD 96 04      [19] 1423 	sub	a, 4 (ix)
   0A50 30 53         [12] 1424 	jr	NC,00104$
                           1425 ;base.c:469: regsPointer[1] = regs.Words.BC;
   0A52 C5            [11] 1426 	push	bc
   0A53 FD E1         [14] 1427 	pop	iy
   0A55 FD 23         [10] 1428 	inc	iy
   0A57 FD 23         [10] 1429 	inc	iy
   0A59 2Ar02r00      [16] 1430 	ld	hl, (#_regs + 2)
   0A5C FD 75 00      [19] 1431 	ld	0 (iy),l
   0A5F FD 74 01      [19] 1432 	ld	1 (iy),h
                           1433 ;base.c:470: regsPointer[2] = regs.Words.DE;
   0A62 FD 21 04 00   [14] 1434 	ld	iy,#0x0004
   0A66 FD 09         [15] 1435 	add	iy, bc
   0A68 2Ar04r00      [16] 1436 	ld	hl, (#_regs + 4)
   0A6B FD 75 00      [19] 1437 	ld	0 (iy),l
   0A6E FD 74 01      [19] 1438 	ld	1 (iy),h
                           1439 ;base.c:471: regsPointer[3] = regs.Words.HL;
   0A71 FD 21 06 00   [14] 1440 	ld	iy,#0x0006
   0A75 FD 09         [15] 1441 	add	iy, bc
   0A77 2Ar06r00      [16] 1442 	ld	hl, (#_regs + 6)
   0A7A FD 75 00      [19] 1443 	ld	0 (iy),l
   0A7D FD 74 01      [19] 1444 	ld	1 (iy),h
                           1445 ;base.c:475: if(length > 8) {
   0A80 3E 08         [ 7] 1446 	ld	a,#0x08
   0A82 DD 96 04      [19] 1447 	sub	a, 4 (ix)
   0A85 30 1E         [12] 1448 	jr	NC,00104$
                           1449 ;base.c:476: regsPointer[4] = regs.Words.IX;
   0A87 FD 21 08 00   [14] 1450 	ld	iy,#0x0008
   0A8B FD 09         [15] 1451 	add	iy, bc
   0A8D 2Ar08r00      [16] 1452 	ld	hl, (#_regs + 8)
   0A90 FD 75 00      [19] 1453 	ld	0 (iy),l
   0A93 FD 74 01      [19] 1454 	ld	1 (iy),h
                           1455 ;base.c:477: regsPointer[5] = regs.Words.IY;
   0A96 21 0A 00      [10] 1456 	ld	hl,#0x000a
   0A99 09            [11] 1457 	add	hl,bc
   0A9A 4D            [ 4] 1458 	ld	c,l
   0A9B 44            [ 4] 1459 	ld	b,h
   0A9C ED 5Br0Ar00   [20] 1460 	ld	de, (#_regs + 10)
   0AA0 7B            [ 4] 1461 	ld	a,e
   0AA1 02            [ 7] 1462 	ld	(bc),a
   0AA2 03            [ 6] 1463 	inc	bc
   0AA3 7A            [ 4] 1464 	ld	a,d
   0AA4 02            [ 7] 1465 	ld	(bc),a
                           1466 ;base.c:480: if(length > 12) {
   0AA5                    1467 00104$:
                           1468 ;base.c:486: SendBytes((byte*)&(pendingCommand.buffer[2]), length+1, true);
   0AA5 DD 4E 04      [19] 1469 	ld	c,4 (ix)
   0AA8 06 00         [ 7] 1470 	ld	b,#0x00
   0AAA 03            [ 6] 1471 	inc	bc
   0AAB 3E 01         [ 7] 1472 	ld	a,#0x01
   0AAD F5            [11] 1473 	push	af
   0AAE 33            [ 6] 1474 	inc	sp
   0AAF C5            [11] 1475 	push	bc
   0AB0 21r18r00      [10] 1476 	ld	hl,#(_pendingCommand + 0x000c)
   0AB3 E5            [11] 1477 	push	hl
   0AB4 CDr00r00      [17] 1478 	call	_SendBytes
   0AB7 F1            [10] 1479 	pop	af
   0AB8 F1            [10] 1480 	pop	af
   0AB9 33            [ 6] 1481 	inc	sp
   0ABA DD E1         [14] 1482 	pop	ix
   0ABC C9            [10] 1483 	ret
                           1484 ;base.c:489: void SendErrorMessage(char* message)
                           1485 ;	---------------------------------
                           1486 ; Function SendErrorMessage
                           1487 ; ---------------------------------
   0ABD                    1488 _SendErrorMessage::
                           1489 ;base.c:491: byte length = strlen(message);
   0ABD C1            [10] 1490 	pop	bc
   0ABE E1            [10] 1491 	pop	hl
   0ABF E5            [11] 1492 	push	hl
   0AC0 C5            [11] 1493 	push	bc
   0AC1 E5            [11] 1494 	push	hl
   0AC2 CDr00r00      [17] 1495 	call	_strlen
   0AC5 F1            [10] 1496 	pop	af
   0AC6 45            [ 4] 1497 	ld	b,l
                           1498 ;base.c:492: SendByte(length, false);
   0AC7 C5            [11] 1499 	push	bc
   0AC8 AF            [ 4] 1500 	xor	a, a
   0AC9 F5            [11] 1501 	push	af
   0ACA 33            [ 6] 1502 	inc	sp
   0ACB C5            [11] 1503 	push	bc
   0ACC 33            [ 6] 1504 	inc	sp
   0ACD CDrE9r0A      [17] 1505 	call	_SendByte
   0AD0 F1            [10] 1506 	pop	af
   0AD1 C1            [10] 1507 	pop	bc
                           1508 ;base.c:493: SendBytes((byte*)message, length, true);
   0AD2 48            [ 4] 1509 	ld	c,b
   0AD3 06 00         [ 7] 1510 	ld	b,#0x00
   0AD5 3E 01         [ 7] 1511 	ld	a,#0x01
   0AD7 F5            [11] 1512 	push	af
   0AD8 33            [ 6] 1513 	inc	sp
   0AD9 C5            [11] 1514 	push	bc
   0ADA 21 05 00      [10] 1515 	ld	hl, #5
   0ADD 39            [11] 1516 	add	hl, sp
   0ADE 4E            [ 7] 1517 	ld	c, (hl)
   0ADF 23            [ 6] 1518 	inc	hl
   0AE0 46            [ 7] 1519 	ld	b, (hl)
   0AE1 C5            [11] 1520 	push	bc
   0AE2 CDr00r00      [17] 1521 	call	_SendBytes
   0AE5 F1            [10] 1522 	pop	af
   0AE6 F1            [10] 1523 	pop	af
   0AE7 33            [ 6] 1524 	inc	sp
   0AE8 C9            [10] 1525 	ret
                           1526 ;base.c:496: void SendByte(byte datum, bool push)
                           1527 ;	---------------------------------
                           1528 ; Function SendByte
                           1529 ; ---------------------------------
   0AE9                    1530 _SendByte::
                           1531 ;base.c:498: SendBytes(&datum, 1, push);
   0AE9 21 02 00      [10] 1532 	ld	hl,#0x0002
   0AEC 39            [11] 1533 	add	hl,sp
   0AED 4D            [ 4] 1534 	ld	c,l
   0AEE 44            [ 4] 1535 	ld	b,h
   0AEF 21 03 00      [10] 1536 	ld	hl, #3+0
   0AF2 39            [11] 1537 	add	hl, sp
   0AF3 7E            [ 7] 1538 	ld	a, (hl)
   0AF4 F5            [11] 1539 	push	af
   0AF5 33            [ 6] 1540 	inc	sp
   0AF6 21 01 00      [10] 1541 	ld	hl,#0x0001
   0AF9 E5            [11] 1542 	push	hl
   0AFA C5            [11] 1543 	push	bc
   0AFB CDr00r00      [17] 1544 	call	_SendBytes
   0AFE F1            [10] 1545 	pop	af
   0AFF F1            [10] 1546 	pop	af
   0B00 33            [ 6] 1547 	inc	sp
   0B01 C9            [10] 1548 	ret
                           1549 ;base.c:501: void HandleConnectionLifetime()
                           1550 ;	---------------------------------
                           1551 ; Function HandleConnectionLifetime
                           1552 ; ---------------------------------
   0B02                    1553 _HandleConnectionLifetime::
                           1554 ;base.c:503: bool wasPreviouslyConnected = clientIsConnected;
   0B02 21r00r00      [10] 1555 	ld	hl,#_clientIsConnected + 0
   0B05 4E            [ 7] 1556 	ld	c, (hl)
                           1557 ;base.c:504: clientIsConnected = ClientIsConnected();
   0B06 C5            [11] 1558 	push	bc
   0B07 CDr00r00      [17] 1559 	call	_ClientIsConnected
   0B0A C1            [10] 1560 	pop	bc
   0B0B FD 21r00r00   [14] 1561 	ld	iy,#_clientIsConnected
   0B0F FD 75 00      [19] 1562 	ld	0 (iy),l
                           1563 ;base.c:506: if(clientIsConnected && !wasPreviouslyConnected) {
   0B12 FD 7E 00      [19] 1564 	ld	a,0 (iy)
   0B15 B7            [ 4] 1565 	or	a, a
   0B16 28 1A         [12] 1566 	jr	Z,00102$
   0B18 79            [ 4] 1567 	ld	a,c
   0B19 B7            [ 4] 1568 	or	a, a
   0B1A 20 16         [12] 1569 	jr	NZ,00102$
                           1570 ;base.c:507: print("Client connected!\r\n");
   0B1C C5            [11] 1571 	push	bc
   0B1D 21r46r0B      [10] 1572 	ld	hl,#___str_21
   0B20 E5            [11] 1573 	push	hl
   0B21 CDr00r00      [17] 1574 	call	_printf
   0B24 F1            [10] 1575 	pop	af
   0B25 C1            [10] 1576 	pop	bc
                           1577 ;base.c:508: getDataBuffer.dataPointer = &(getDataBuffer.data[0]);
   0B26 21r2Fr00      [10] 1578 	ld	hl,#_getDataBuffer
   0B29 22r2Fr02      [16] 1579 	ld	((_getDataBuffer + 0x0200)), hl
                           1580 ;base.c:509: getDataBuffer.remainingData = 0;
   0B2C 21 00 00      [10] 1581 	ld	hl,#0x0000
   0B2F 22r31r02      [16] 1582 	ld	((_getDataBuffer + 0x0202)), hl
   0B32                    1583 00102$:
                           1584 ;base.c:512: if(!clientIsConnected) {
   0B32 3Ar00r00      [13] 1585 	ld	a,(#_clientIsConnected + 0)
                           1586 ;base.c:513: if(wasPreviouslyConnected) {
   0B35 B7            [ 4] 1587 	or	a,a
   0B36 C0            [11] 1588 	ret	NZ
   0B37 B1            [ 4] 1589 	or	a,c
   0B38 CAr00r00      [10] 1590 	jp	Z,_WaitForClientConnection
                           1591 ;base.c:514: print("Disconnected...\r\n");
   0B3B 21r5Ar0B      [10] 1592 	ld	hl,#___str_22
   0B3E E5            [11] 1593 	push	hl
   0B3F CDr00r00      [17] 1594 	call	_printf
   0B42 F1            [10] 1595 	pop	af
                           1596 ;base.c:517: WaitForClientConnection();
   0B43 C3r00r00      [10] 1597 	jp  _WaitForClientConnection
   0B46                    1598 ___str_21:
   0B46 43 6C 69 65 6E 74  1599 	.ascii "Client connected!"
        20 63 6F 6E 6E 65
        63 74 65 64 21
   0B57 0D                 1600 	.db 0x0d
   0B58 0A                 1601 	.db 0x0a
   0B59 00                 1602 	.db 0x00
   0B5A                    1603 ___str_22:
   0B5A 44 69 73 63 6F 6E  1604 	.ascii "Disconnected..."
        6E 65 63 74 65 64
        2E 2E 2E
   0B69 0D                 1605 	.db 0x0d
   0B6A 0A                 1606 	.db 0x0a
   0B6B 00                 1607 	.db 0x00
                           1608 ;base.c:523: void ReadFromPort(byte portNumber, byte* destinationAddress, uint size, bool autoIncrement) __naked
                           1609 ;	---------------------------------
                           1610 ; Function ReadFromPort
                           1611 ; ---------------------------------
   0B6C                    1612 _ReadFromPort::
                           1613 ;base.c:555: __endasm;
   0B6C DD E5         [15] 1614 	push	ix
   0B6E DD 21 04 00   [14] 1615 	ld	ix,#4
   0B72 DD 39         [15] 1616 	add	ix,sp
   0B74 DD 4E 00      [19] 1617 	ld	c,(ix) ;C=(first) port number
   0B77 DD 6E 01      [19] 1618 	ld	l,1(ix)
   0B7A DD 66 02      [19] 1619 	ld	h,2(ix) ;HL=dest address
   0B7D DD 5E 03      [19] 1620 	ld	e,3(ix)
   0B80 DD 56 04      [19] 1621 	ld	d,4(ix) ;DE=size
   0B83 DD 7E 05      [19] 1622 	ld	a,5(ix) ;A=autoIncrement
   0B86 B7            [ 4] 1623 	or	a,a
   0B87 28 02         [12] 1624 	jr	z,RFP_DO
   0B89 3E 0C         [ 7] 1625 	ld	a,#0x0C ;INC C
   0B8B                    1626 	RFP_DO:
   0B8B 32r91r0B      [13] 1627 	ld	(RFP_INCC),a
   0B8E                    1628 	RFP_LOOP:
   0B8E 7E            [ 7] 1629 	ld	a,(hl)
   0B8F ED A2         [16] 1630 	ini
   0B91                    1631 	RFP_INCC:
   0B91 00            [ 4] 1632 	nop	;INC C on autoincrement, NOP otherwise
   0B92 1B            [ 6] 1633 	dec	de
   0B93 7A            [ 4] 1634 	ld	a,d
   0B94 B3            [ 4] 1635 	or	e
   0B95 20 F7         [12] 1636 	jr	nz,RFP_LOOP
   0B97 DD E1         [14] 1637 	pop	ix
   0B99 C9            [10] 1638 	ret
                           1639 ;base.c:558: void WriteToPort(byte portNumber, byte value)
                           1640 ;	---------------------------------
                           1641 ; Function WriteToPort
                           1642 ; ---------------------------------
   0B9A                    1643 _WriteToPort::
                           1644 ;base.c:571: __endasm;
   0B9A DD E5         [15] 1645 	push	ix
   0B9C DD 21 04 00   [14] 1646 	ld	ix,#4
   0BA0 DD 39         [15] 1647 	add	ix,sp
   0BA2 DD 4E 00      [19] 1648 	ld	c,(ix) ;C=port number
   0BA5 DD 7E 01      [19] 1649 	ld	a,1(ix) ;A=value
   0BA8 ED 79         [12] 1650 	out	(c),a
   0BAA DD E1         [14] 1651 	pop	ix
   0BAC C9            [10] 1652 	ret
   0BAD C9            [10] 1653 	ret
                           1654 	.area _CODE
                           1655 	.area _INITIALIZER
   0000                    1656 __xinit__clientIsConnected:
   0000 00                 1657 	.db #0x00	; 0
   0001                    1658 __xinit__verbose:
   0001 00                 1659 	.db #0x00	; 0
   0002                    1660 __xinit__executeCommandPayloadLengths:
   0002 04                 1661 	.db #0x04	; 4
   0003 0A                 1662 	.db #0x0a	; 10
   0004 0E                 1663 	.db #0x0e	; 14
   0005 16                 1664 	.db #0x16	; 22
                           1665 	.area _CABS (ABS)
